<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello-World</title>
    <url>/2021/06/08/Hello-World/</url>
    <content><![CDATA[
        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
      
        <h3 id="创建一个文档"   >
          <a href="#创建一个文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个文档" class="headerlink" title="创建一个文档"></a>创建一个文档</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="创建一个页面"   >
          <a href="#创建一个页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;new my pageName&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="生成静态页面至public目录"   >
          <a href="#生成静态页面至public目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>


        <h3 id="部署到GitHub"   >
          <a href="#部署到GitHub" class="heading-link"><i class="fas fa-link"></i></a><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<span id="more"></span>


        <h3 id="清理public目录的内容"   >
          <a href="#清理public目录的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理public目录的内容" class="headerlink" title="清理public目录的内容"></a>清理public目录的内容</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></div></figure>


        <h3 id="指令缩写"   >
          <a href="#指令缩写" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo n    （hexo new）</span><br><span class="line">$ hexo g    （hexo generate）</span><br><span class="line">$ hexo d    （hexo deploy）</span><br></pre></td></tr></table></div></figure>


        <h3 id="组合指令"   >
          <a href="#组合指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合指令" class="headerlink" title="组合指令"></a>组合指令</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">$ hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Hexo常用指令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Top</title>
    <url>/2021/06/08/Linux-Top/</url>
    <content><![CDATA[
        <h1 id="Linux命令之Top"   >
          <a href="#Linux命令之Top" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux命令之Top" class="headerlink" title="Linux命令之Top"></a>Linux命令之Top</h1>
      <p><img src="/mdimages/image-20210527113329108.png" alt="image-20210527113329108"></p>

        <h3 id="第一行，任务队列信息，同uptime命令的执行结果"   >
          <a href="#第一行，任务队列信息，同uptime命令的执行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一行，任务队列信息，同uptime命令的执行结果" class="headerlink" title="第一行，任务队列信息，同uptime命令的执行结果"></a>第一行，任务队列信息，同uptime命令的执行结果</h3>
      <p>系统时间：11:32:32</p>
<p>运行时间：up 61 days, 23:26</p>
<p>当前登录用户：1 user</p>
<p>负载均衡（uptime）：load average:  1.35, 1.25, 1.29</p>
<p>​                                  average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>（load average数据是每隔5秒检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5，就表明系统在超负荷运转）</p>
<span id="more"></span>


        <h3 id="第二行，Tasks-任务（进程）"   >
          <a href="#第二行，Tasks-任务（进程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二行，Tasks-任务（进程）" class="headerlink" title="第二行，Tasks - 任务（进程）"></a>第二行，Tasks - 任务（进程）</h3>
      <p>总进程：231total，运行：2 running，休眠：229 sleeping，停止：0 stopped，僵尸进程：0 zombie</p>

        <h3 id="第三行，cpu状态信息"   >
          <a href="#第三行，cpu状态信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三行，cpu状态信息" class="headerlink" title="第三行，cpu状态信息"></a>第三行，cpu状态信息</h3>
      <p>15.2%us【user space】— 用户空间占用CPU的百分比。</p>
<p>4.9%sy 【sysctl】— 内核空间占用CPU的百分比。</p>
<p>0.0%ni  — 改变过优先级的进程占用CPU的百分比。</p>
<p>79.8%id 【idolt】 — 空闲CPU百分比。</p>
<p>0.0%wa 【wait】 — IO等待占用CPU的百分比。</p>
<p>0.0%hi 【Hardware IRQ】— 硬中断占用CPU的百分比。</p>
<p>0.2%si 【Software Interrupts】— 软中断占用CPU的百分比。</p>
<p>0.0%st 【】</p>

        <h3 id="第四行，内存状态-Mem"   >
          <a href="#第四行，内存状态-Mem" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四行，内存状态-Mem" class="headerlink" title="第四行，内存状态 Mem"></a>第四行，内存状态 Mem</h3>
      <p>8060540k total  总内存大小, 6989544k used 已使用内存大小, 1070996k free 空闲内存大小, 1143720k buffers 【缓存的内存量】</p>

        <h3 id="第五行，swap交换分区信息"   >
          <a href="#第五行，swap交换分区信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五行，swap交换分区信息" class="headerlink" title="第五行，swap交换分区信息"></a>第五行，swap交换分区信息</h3>
      <p>8208380k total 总内存大小, 942352k used 已使用内存大小,  7266028k free 空闲内存大小, 3101300k cached 【缓冲的交换区总量】</p>
<p>补充说明：可用内存 =  free + buffer + cached</p>
<p>在对内存监控中，时刻注意swap 交换区的 used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，表明真正的内存不够用了。</p>

        <h3 id="第六行，空行"   >
          <a href="#第六行，空行" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h3>
      
        <h3 id="第七行以下：各进程（任务）的状态监控"   >
          <a href="#第七行以下：各进程（任务）的状态监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h3>
      <p>PID —- 进程id</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值，负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p>S — 进程状态。D代表不可中断的睡眠状态；R代表运行；S代表睡眠；T代表跟踪/停止；Z代表僵尸进程。</p>
<p>%CPU — 上次更新到现在CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100 秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<p>以下信息默认没展示:</p>
<p>DATA  —  可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位kb。【简单理解，数据占用的内存，真正的该程序要求的数据空间，是真正在运行中要使用的】。</p>
<p>CODE — 可执行代码占用的物理内存大小，单位kb。</p>
<p>可以通过指令f进入 编排基本视图，这里列出了所有可在top基本视图中显示的进程字段，有带 “ * “ 的并且标注为大写字母的字段是可显示的，没有带 “ * “ 并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以移动上下键到这两个字段，然后按d键选择这两个字段，然后按q退出就可以。【提示：按f进入编排基本视图后，如果想进行进程字段显示顺序做修改，使用上下键移动到该字段，然后按右键（即选中该字段），然后上下键移动到需要的位置即可】</p>
<p><img src="/mdimages/image-20210527204228170.png" alt="image-20210527204228170"></p>
<hr>

        <h3 id="VIRT-virtual-memory-usage-虚拟内存"   >
          <a href="#VIRT-virtual-memory-usage-虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#VIRT-virtual-memory-usage-虚拟内存" class="headerlink" title="VIRT :  virtual memory usage 虚拟内存"></a>VIRT :  virtual memory usage 虚拟内存</h3>
      <p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等</p>
<p>注意：假如进程申请100m的内存，但实际只使用了10m,那么它会申请100m，而不是实际的使用量10m.</p>

        <h3 id="RES-resident-memory-usage-常驻内存（单位kb）"   >
          <a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="heading-link"><i class="fas fa-link"></i></a><a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="headerlink" title="RES  :  resident memory usage 常驻内存（单位kb）"></a>RES  :  resident memory usage 常驻内存（单位kb）</h3>
      <p>1、进程当前使用的内存大小，但不包括swap out</p>
<p>2、包含其他进程的共享</p>
<p>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反</p>
<p>补充说明：<strong>当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT</strong></p>

        <h3 id="SHR-shared-memory-共享内存"   >
          <a href="#SHR-shared-memory-共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#SHR-shared-memory-共享内存" class="headerlink" title="SHR : shared memory 共享内存"></a>SHR : shared memory 共享内存</h3>
      <p>1、除了自身进程的共享内存，也包括其他进行的共享内存</p>
<p>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p>
<p>3、计算某个进程所占物理内存大小公式：RES - SHR</p>
<p>4、swap out后，它将会降下来</p>

        <h3 id="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"   >
          <a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="heading-link"><i class="fas fa-link"></i></a><a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="headerlink" title="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"></a>top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">s ：改变画面更新频率。</span><br><span class="line"></span><br><span class="line">l ：关闭或开启第一行top信息。</span><br><span class="line"></span><br><span class="line">t ：关闭或开启第二行Tasks和第三行Cpus信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">m ：关闭或开启第四行Mem和第五行Swap信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">N ：以PID的大小进行降序排序。</span><br><span class="line"></span><br><span class="line">P：以CPU占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">M：以内存占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">h：显示帮助</span><br><span class="line"></span><br><span class="line">n：设置在进程列表所显示进程的数量</span><br><span class="line"></span><br><span class="line">q：退出top</span><br></pre></td></tr></table></div></figure>




        <h3 id="top命令的使用方法"   >
          <a href="#top命令的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#top命令的使用方法" class="headerlink" title="top命令的使用方法"></a>top命令的使用方法</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">使用格式：top [-] [p] [S] [s] [i] [c]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">p：通过指定监控进程ID来显示某个进程的状态。top -p 进程ID</span><br><span class="line"></span><br><span class="line">S：指定累计模式。</span><br><span class="line"></span><br><span class="line">s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line"></span><br><span class="line">i：使top不显示任何闲置或者僵尸进程。</span><br><span class="line"></span><br><span class="line">c：显示整个命令行而不只是显示命令名称。</span><br></pre></td></tr></table></div></figure>




        <h3 id="Linux查看物理CPU个数、核数、逻辑CPU个数"   >
          <a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><strong>Linux查看物理CPU个数、核数、逻辑CPU个数</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上分配和TLAB</title>
    <url>/2021/06/09/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB/</url>
    <content><![CDATA[
        <h2 id="关于栈上分配和TLAB的理解"   >
          <a href="#关于栈上分配和TLAB的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于栈上分配和TLAB的理解" class="headerlink" title="关于栈上分配和TLAB的理解"></a><strong>关于栈上分配和TLAB的理解</strong></h2>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>在java程序中，new出来的对象时分配在堆空间中的，但是实际的情况是，大部分new出来的对象会进入堆空间中，而并非是全部的对象，其实还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB。</p>

        <h2 id="栈上分配"   >
          <a href="#栈上分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2>
      
        <h4 id="栈上分配是什么？"   >
          <a href="#栈上分配是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配是什么？" class="headerlink" title="栈上分配是什么？"></a>栈上分配是什么？</h4>
      <p>JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上（线程私有，属于栈内存），这样随着方法的调用结束，栈空间的回收就会随着栈上分配的打散后的对象回收掉，不再给GC增加额外的无用负担，从而提升应用程序整体的性能。</p>
<span id="more"></span>


        <h4 id="为什么需要栈上分配？"   >
          <a href="#为什么需要栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要栈上分配？" class="headerlink" title="为什么需要栈上分配？"></a>为什么需要栈上分配？</h4>
      <p>在应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用而开始，方法的调用结束而结束，对于这种对象，就应该考虑将该对象不分配在堆空间中。因为一旦分配在堆空间中，当方法调用结束，没有了引用指向该对象，该对象就需要被GC回收，而如果存在大量的这种情况，对GC来说无疑时一种负担。</p>

        <h4 id="如何开启栈上分配？"   >
          <a href="#如何开启栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启栈上分配？" class="headerlink" title="如何开启栈上分配？"></a>如何开启栈上分配？</h4>
      <p>栈上分配需要的前提：</p>
<p>（1）开启逃逸分析（-XX:+DoEscapeAnalysis）</p>
<p>逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，在Server虚拟机模式下才可以开启（jdk1.6默认开启）</p>
<p>（2）开启标量替换（-XX:+EliminateAllocations）</p>
<p>标量替换的作用是允许将对象根据属性打散后分配在栈上，默认该配置为开启</p>

        <h4 id="如何查看逃逸分析的筛选结果？"   >
          <a href="#如何查看逃逸分析的筛选结果？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何查看逃逸分析的筛选结果？" class="headerlink" title="如何查看逃逸分析的筛选结果？"></a>如何查看逃逸分析的筛选结果？</h4>
      <p>配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果</p>

        <h2 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2>
      
        <h4 id="TLAB是什么？"   >
          <a href="#TLAB是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB是什么？" class="headerlink" title="TLAB是什么？"></a>TLAB是什么？</h4>
      <p>全程叫做：Thread Local Allocation Buffer 即线程本地分配缓存</p>
<p>就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的）。</p>

        <h4 id="为什么需要TLAB？"   >
          <a href="#为什么需要TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要TLAB？" class="headerlink" title="为什么需要TLAB？"></a>为什么需要TLAB？</h4>
      <p>一般来说，对象分配在堆上，而堆是一个全局共享的区域，当多个线程同一时刻操作堆内存分配对象空间时，就需要进行同步，而同步带来的效果就是对象分配效率变差（尽管JVM采用了CAS的形式处理分配失败的情况），但是对于存在竞争激烈的分配场合仍然会导致效率变差。（简而言之：需要TLAB的原因就是提高对象在堆上的分配效率）</p>

        <h4 id="如何开启TLAB？"   >
          <a href="#如何开启TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启TLAB？" class="headerlink" title="如何开启TLAB？"></a>如何开启TLAB？</h4>
      <p>JVM默认开启了TLAB功能，可以使用-XX:+UseTLAB 显示是否开启。</p>

        <h4 id="如何观察TLAB使用情况？"   >
          <a href="#如何观察TLAB使用情况？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何观察TLAB使用情况？" class="headerlink" title="如何观察TLAB使用情况？"></a>如何观察TLAB使用情况？</h4>
      <p>JVM提供了-XX:+PrintTLAB，可以打开跟踪TLAB的使用情况。</p>

        <h4 id="如何调整TLAB默认大小？"   >
          <a href="#如何调整TLAB默认大小？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何调整TLAB默认大小？" class="headerlink" title="如何调整TLAB默认大小？"></a>如何调整TLAB默认大小？</h4>
      <p>-XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小。</p>

        <h2 id="栈上分配和TLAB的对比"   >
          <a href="#栈上分配和TLAB的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配和TLAB的对比" class="headerlink" title="栈上分配和TLAB的对比"></a>栈上分配和TLAB的对比</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">针对点</th>
<th align="center">处于对象分配流程的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈上分配</td>
<td align="center">避免GC无畏负担</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TLAB</td>
<td align="center">加速堆上对象的分配</td>
<td align="center">2</td>
</tr>
</tbody></table></div>

        <h2 id="对象分配流程图"   >
          <a href="#对象分配流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象分配流程图" class="headerlink" title="对象分配流程图"></a>对象分配流程图</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://processon.com/diagraming/609de1d91e08533129c22d0f" >对象分配流程图 - ProcessOn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/mdimages/image-20210514104238560.png" alt="image-20210514104238560"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的强、软、弱、虚引用</title>
    <url>/2021/06/09/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[
        <h1 id="Java对象的强引用、软引用、弱引用、虚引用"   >
          <a href="#Java对象的强引用、软引用、弱引用、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对象的强引用、软引用、弱引用、虚引用" class="headerlink" title="Java对象的强引用、软引用、弱引用、虚引用"></a>Java对象的强引用、软引用、弱引用、虚引用</h1>
      
        <h3 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>
      <p>在Java中，除了基本数据类型外，还有引用数据类型；Java根据其生命周期的长短，将引用分为以下4类：强引用、软引用、弱引用和虚引用。</p>

        <h3 id="基本数据类型"   >
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3>
      <ul>
<li>整数类型(byte、short、int、long)</li>
<li>浮点类型(float、double)</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>

        <h3 id="引用数据类型"   >
          <a href="#引用数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3>
      <ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
<span id="more"></span>


        <h3 id="基本数据类型图"   >
          <a href="#基本数据类型图" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型图" class="headerlink" title="基本数据类型图"></a>基本数据类型图</h3>
      <p><img src="/mdimages/image-20210609235746769.png" alt="image-20210609235746769"></p>

        <h3 id="引用类图"   >
          <a href="#引用类图" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类图" class="headerlink" title="引用类图"></a>引用类图</h3>
      <p><img src="/mdimages/image-20210610000110261.png" alt="image-20210610000110261"></p>

        <h3 id="一、强引用（默认支持模式）"   >
          <a href="#一、强引用（默认支持模式）" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、强引用（默认支持模式）" class="headerlink" title="一、强引用（默认支持模式）"></a>一、强引用（默认支持模式）</h3>
      <p>把一个对象赋给一个引用变量，这个引用变量就是一个强引用。(如：Object obj = new Object()中的obj就是强引用)。</p>
<p>即通过关键字new创建的对象所关联的引用就是强引用，此时它处于可达状态（如果不懂可达状态的概念，可参阅GCRoots相关知识），当JVM内存空间不足时，JVM宁愿抛出OOM运行时错误使程序终止，也不会回收“存活”对象来解决内存不足的问题。因此强引用是造成java内存泄漏的主要原因之一。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为Null，一般认为就是可以被垃圾收集的了（具体回收时机要看垃圾收集策略）。</p>
<p>知识补充：当一个对象处于可达状态时，jvm会对其标记为存活对象。</p>

        <h3 id="二、软引用"   >
          <a href="#二、软引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h3>
      <p>软引用是一种相对于强引用弱化一些的引用，需要用java.lang.ref.SoftReference类来实现。</p>
<p>对于只要软引用的对象来说，当系统内存充足时，它不会被回收，当系统内存不足时，它会被回收。</p>
<p>软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中，后续可以调用ReferenceQueue的poll()方法来检查是否有它所关联的对象被回收。如果队列为空，将返回一个null，否则返回队列中前面的一个Reference对象。</p>

        <h4 id="应用场景："   >
          <a href="#应用场景：" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>  软引用通常用在对内存敏感的程序中，比如高速缓存就使用了软引用，内存足够时就保留，不足够时就回收。如MyBatis中就用到。</p>

        <h4 id="代码演示："   >
          <a href="#代码演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">        <span class="comment">//这里将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建大对象数组30M</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;软引用==&gt;&quot;</span>+reference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<p><img src="/mdimages/image-20210611004111118.png" alt="image-20210611004111118"></p>
<p>设置JVM参数：-Xms10m -Xmx10m -XX:+PrintGCDetails（初始化堆内存大小，堆内存最大大小，开启GC回收日志）</p>
<p><img src="/mdimages/image-20210611004543872.png" alt="image-20210611004543872"></p>
<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;956K(9728K), <span class="number">0.0008888</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1372K-&gt;504K(2560K)] 1825K-&gt;1044K(9728K), <span class="number">0.0010868</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 504K-&gt;488K(2560K)] 1044K-&gt;1068K(9728K), <span class="number">0.0009916</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 488K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 580K-&gt;976<span class="title">K</span><span class="params">(7168K)</span>] 1068K-&gt;976<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0093101 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 976K-&gt;976K(9728K), <span class="number">0.0004390</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 976K-&gt;958<span class="title">K</span><span class="params">(7168K)</span>] 976K-&gt;958<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0095406 secs] [Times: user</span>=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">软引用==&gt;<span class="keyword">null</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 61K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">3</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f700</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 958K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">13</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff6efa08</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3554K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 391<span class="title">K</span>, <span class="title">capacity</span> 394<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Exception</span> <span class="title">in</span> <span class="title">thread</span> &quot;<span class="title">main</span>&quot; <span class="title">java</span>.<span class="title">lang</span>.<span class="title">OutOfMemoryError</span>: <span class="title">Java</span> <span class="title">heap</span> <span class="title">space</span></span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">mybatis</span>.<span class="title">Main</span>.<span class="title">main</span>(<span class="title">Main</span>.<span class="title">java</span>:12)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 1</span></span><br></pre></td></tr></table></div></figure>

<p>发现当内存不够的时候软引用对象就会被回收。</p>

        <h3 id="三、弱引用"   >
          <a href="#三、弱引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h3>
      <p>弱引用需要通过java.lang.ref.WeakReference类实现。生命周期比软引用更短。</p>
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都将回收该对象占用的内存。</p>
<p>弱引用还可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，JVM就会把这个弱引用加入与之关联的引用队列中。</p>

        <h4 id="应用场景：-1"   >
          <a href="#应用场景：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>弱引用同样可用于内存敏感的缓存。</p>
<p>弱引用适合解决某些地方的内存泄露问题，比如ThreadLocal，ThreadLocal静态内部类ThreadLocalMap中的Entiry中的key就是一个虚引用。</p>

        <h4 id="代码演示：-1"   >
          <a href="#代码演示：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;强引用对象====&gt;&quot;</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象====&gt;&quot;</span>+weakReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//手动触发垃圾回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========GC回收后的结果==========&quot;</span>);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">强引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">弱引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">==========GC回收后的结果==========</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="补充WeakHashMap"   >
          <a href="#补充WeakHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充WeakHashMap" class="headerlink" title="补充WeakHashMap"></a>补充WeakHashMap</h4>
      <p>WeakHashMap的键是”弱键”，也就是键的引用是一个弱引用。</p>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">7</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;<span class="comment">//这里将key置为null，让其不存在强引用</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map+<span class="string">&quot;===&gt;&quot;</span>+map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;&#125;===&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="四、虚引用"   >
          <a href="#四、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h3>
      <p>虚引用需要java.lang.ref.PhantomReference类实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用，也不能通过它访问对象，必须和引用队列(ReferenceQueue)联合使用。</p>
<p>主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。PhantomReference的get方法总是返回null,无论在GC前还是GC后，PhantomReference在GC前poll方法是null，GC后poll方法是获取被回收的对象，设置虚引用关联的唯一目的就是在这个对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步的处理（类似SpringAop的后置通知）。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>Java允许使用finalize()方法在垃圾回收器将对象从内存中清除出去之前做必要的清理工作。</p>

        <h4 id="应用场景：-2"   >
          <a href="#应用场景：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>可用来跟踪对象被垃圾回收器回收的时候添加一些处理。</p>

        <h4 id="代码演示：-2"   >
          <a href="#代码演示：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <p>对象无重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//这里睡0.1秒确保GC线程执行完再打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;在打印看看&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">第一次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line">在打印看看<span class="keyword">null</span></span><br></pre></td></tr></table></div></figure>

<p>注意：</p>
<p>ReferenceQueue.poll()方法调用拿到对象后，再调用就无该对象了。</p>
<p>代码演示：</p>
<p>对象重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC之后&quot;</span>+queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC要把我清除了/(ㄒoㄒ)/~~......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">GC要把我清除了/(ㄒoㄒ)/~~......</span><br><span class="line">第一次GC之后<span class="keyword">null</span></span><br><span class="line">第二次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="结论"   >
          <a href="#结论" class="heading-link"><i class="fas fa-link"></i></a><a href="#结论" class="headerlink" title="结论"></a>结论</h4>
      <p>对于虚引用，如果被引用的对象没有重写finalize方法，那么在第一次垃圾回收将该对象销毁之后，就会将虚引用对象添加到引用队列中。如果被引用的对象重写了finalize方法，那么则是在执行完第二次垃圾回收后，才将虚引用对象添加到其关联的引用队列中。</p>

        <h4 id="ReferenceQueue引用队列"   >
          <a href="#ReferenceQueue引用队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReferenceQueue引用队列" class="headerlink" title="ReferenceQueue引用队列"></a>ReferenceQueue引用队列</h4>
      <p>对象在被回收之前要被引用队列保存一下。GC之前对象不放在队列中，GC之后对象才放入队列中。</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <ul>
<li>强引用是不会被垃圾回收器随意回收的，也是造成java内存溢出的主要原因之一。</li>
<li>软引用是通过java.lang.ref.SoftReference类来实现，当JVM内存不足时，便会回收软引用所引用的对象。</li>
<li>弱引用是通过java.lang.ref.WeakReference类来实现，只要垃圾回收器回收垃圾时，无论内存足不足够都会把弱引用回收掉。</li>
<li>虚引用是通过java.lang.ref.PhantomReference类来实现，若一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPool线程池</title>
    <url>/2021/06/11/ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[
        <h1 id="ThreadPool线程池"   >
          <a href="#ThreadPool线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1>
      
        <h3 id="线程池是什么"   >
          <a href="#线程池是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3>
      <p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后再创建线程后自动启动这些任务。</p>

        <h3 id="为什么用线程池"   >
          <a href="#为什么用线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3>
      <p>线程池的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务执行。</p>
<p>主要的特点是：线程复用；控制最大并发数；管理线程。</p>
<p>好处：</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<span id="more"></span></li>
</ol>

        <h3 id="线程池如何使用"   >
          <a href="#线程池如何使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h3>
      <p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类。</p>
<p>类图：</p>
<p><img src="/mdimages/image-20210611153209223.png" alt="image-20210611153209223"></p>
<p>Java通过Executors提供了以下几种线程池：</p>
<ul>
<li><p>Executors.newScheduledThreadPool(int corePoolSize);创建一个支持定时以及周期性执行任务的线程池。</p>
</li>
<li><p>Executors.newWorkStealingPool(int);JDK8新增，使用目前机器上可用的处理器作为它的并行级别。</p>
</li>
<li><p>Executors.newFixedThreadPool(int);创建一个定长的线程池，可控制线程最大并发数，超过的线程会在队列中等待。</p>
</li>
<li><p>Executors.newSingleThreadExecutor();创建只有一个线程的线程池，保证所有任务按照FIFO执行；</p>
</li>
<li><p>Executors.newCachedThreadPool();创建一个可缓存线程池；</p>
<p>以上线程池除了newWorkStealingPool底层是使用ForkJoinPool创建外，其它线程池都是使用ThreadPoolExecutor创建的。</p>
</li>
</ul>

        <h4 id="重点介绍："   >
          <a href="#重点介绍：" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点介绍：" class="headerlink" title="重点介绍："></a>重点介绍：</h4>
      <ol>
<li><p>newFixedThreadPool(int)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;====&gt;&quot;</span>+finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为线程池大小为<span class="number">3</span>，每个任务输出finalI后sleep2秒，可以看到每两秒打印<span class="number">3</span>个数字，并且每两秒始终打印的都是三个线程轮流工作。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newSingleThreadExecutor()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO【先进先出】,LIFO【后进先出】,优先级)执行。</li>
<li>newSingleThreadExecutor创建的线程池corePoolSize和maximimPoolSize都设置为1,它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为newSingleThreadExecutor线程池中始终只有一个工作线程工作，所以可以看到工作的线程始终是同一个。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newCachedThreadPool()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newCachedThreadPool将corePooleSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用的阻塞队列是SynchronousQueue，也即是任务来了就创建线程运行，当线程空闲超过60秒就销毁线程。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//始终保持执行第二个任务的时候第一个任务已经完成</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>* finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cachedThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">从底层可以看出newCachedThreadPool创建的线程池为无线大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newScheduledThreadPool(int corePoolSize)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<p>创建一个周期线程池，支持定时及周期性任务执行。</p>
<p>代码演示1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;delay.....延迟3秒&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//等待任务执行完再关闭</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        <span class="comment">//无论任务是否执行完都立马关闭</span></span><br><span class="line">        <span class="comment">//scheduledThreadPool.shutdownNow();</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程执行..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">main线程执行..........</span><br><span class="line">delay.....延迟<span class="number">3</span>秒</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<p>代码演示2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">04</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">07</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">10</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">13</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">16</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">19</span> CST <span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br><span class="line">表示延迟<span class="number">3</span>秒后每<span class="number">3</span>秒执行一次任务。</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h3 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3>
      
        <h4 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="七大参数说明"   >
          <a href="#七大参数说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#七大参数说明" class="headerlink" title="七大参数说明"></a>七大参数说明</h4>
      <ol>
<li>corePoolSize：线程池中的常驻核心线程数。</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数量，此值必须大于1。</li>
<li>keepAliveTime：多余的空闲线程的存活时间。当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。</li>
<li>unit：keepAliveTime的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。</li>
<li>handler：拒接策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时如何来拒接。</li>
</ol>

        <h4 id="线程池的工作原理"   >
          <a href="#线程池的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h4>
      <ol>
<li>在创建了线程池后，等待提交过来的任务请求。</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做如下判断：</li>
</ol>
<p>​      2.1.如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p>
<p>​      2.2.如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p>
<p>​      2.3.如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p>​      2.4.如果队列满了且正在运行的线程数大于或等于mamimumPoolSize，那么线程池会启动饱和拒接策略来执行；</p>
<p>  3.当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
<p>  4.当一个线程无事可做超过一定时间(keepAliveTime)时，线程池会判断：</p>
<p>​     如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。最后线程池的所有任务完成后它最终会收缩到corePoolSize的大小。</p>

        <h4 id="线程池的拒接策略"   >
          <a href="#线程池的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略" class="headerlink" title="线程池的拒接策略"></a>线程池的拒接策略</h4>
      
        <h5 id="线程池的拒接策略是什么"   >
          <a href="#线程池的拒接策略是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略是什么" class="headerlink" title="线程池的拒接策略是什么"></a>线程池的拒接策略是什么</h5>
      <p>等待队列已经排满了，再也塞不进新任务，同时线程池中的maximumPoolSize也达到了，无法进行为新任务服务，这个时候就需要拒接策略机制合理的处理这个问题。</p>

        <h5 id="JDK内置的拒接策略"   >
          <a href="#JDK内置的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#JDK内置的拒接策略" class="headerlink" title="JDK内置的拒接策略"></a>JDK内置的拒接策略</h5>
      <ul>
<li><p>AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行。</p>
</li>
<li><p>CallerRunsPolicy：”调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p>
</li>
<li><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列尝试再次提交当前任务。</p>
</li>
<li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案。</p>
<p> 以上内置拒接策略均实现了RejectedExecutionHandler接口。</p>
</li>
</ul>
<p><img src="/mdimages/image-20210612141336672.png" alt="image-20210612141336672"></p>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>
      <p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p>
<p>Executors返回的线程池对象的弊端如下：</p>
<ol>
<li><p>newFixedThreadPool和newSingleThreadPool：</p>
<p>允许的请求队列长度为Integer.MAX_VALUE,长度约为21亿左右，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p>newCachedThreadPool和newScheduledThreadPool:</p>
<p>允许的创建最大线程数量为Integer.MAX_VALUE,长度约为21亿左右，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ol>

        <h3 id="自定义线程池核心线程数的考量"   >
          <a href="#自定义线程池核心线程数的考量" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义线程池核心线程数的考量" class="headerlink" title="自定义线程池核心线程数的考量"></a>自定义线程池核心线程数的考量</h3>
      <ul>
<li><p>CPU密集型</p>
<p>任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量。</p>
<p>参考公式：CPU核数+1个线程</p>
</li>
<li><p>IO密集型</p>
<p>任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力，浪费在等待。</p>
<p>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>参考公式：CPU核数/1-阻塞系数      阻塞系数在0.8~0.9之间</p>
<p>比如8核CPU：8/1-0.9=80个线程数</p>
</li>
<li><p>CPU核数计算</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(processors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="知识补充"   >
          <a href="#知识补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2>
      
        <h3 id="阻塞队列"   >
          <a href="#阻塞队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3>
      
        <h4 id="阻塞队列的概念"   >
          <a href="#阻塞队列的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列的概念" class="headerlink" title="阻塞队列的概念"></a>阻塞队列的概念</h4>
      <p>阻塞队列它是一种队列，是一种数据结构，阻塞队列在数据结构中所起的作用如下图所示：</p>
<p><img src="/mdimages/image-20210613135406120.png" alt="image-20210613135406120"></p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li>
<li>当阻塞队列时满时，往队列里添加元素的操作将会被阻塞。</li>
<li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它的线程往空的队列插入新的元素。</li>
<li>视图往已满的阻塞队列中添加元素的线程同样也会被阻塞，直到其它线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来后才继续新增。</li>
</ul>

        <h4 id="使用阻塞队列的好处"   >
          <a href="#使用阻塞队列的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用阻塞队列的好处" class="headerlink" title="使用阻塞队列的好处"></a>使用阻塞队列的好处</h4>
      <p>在多线程环境下，所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤醒。</p>
<p>而使用阻塞队列(BlockingQueue)，不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些操作都交给阻塞队列处理。</p>
<p>在JDK1.5前，在多线程环境下，我们都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，会给我们的程序带来不小的复杂度。</p>

        <h4 id="BlockingQueue的核心方法"   >
          <a href="#BlockingQueue的核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">pull(time,unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">抛出异常</td>
<td align="left">当阻塞队列满时，再往队列里add插入元素会抛出java.lang.IllegalStateException: Queue full；<br />当阻塞队列空时，在往队列里remove移除元素会抛出NoSuchElementException;</td>
</tr>
<tr>
<td align="center">特殊值</td>
<td align="left">插入方法offer(e)，成功返回true，失败返回false；<br />移除方法poll()，成功返回出队列的元素，队列里面没有就返回null;</td>
</tr>
<tr>
<td align="center">一直阻塞</td>
<td align="left">当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或者响应中断退出；<br />当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用；</td>
</tr>
<tr>
<td align="center">超时退出</td>
<td align="left">当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出；<br />当阻塞队列空时，队列会阻塞消费者线程一定时间，超过限时后消费者线程会退出；</td>
</tr>
</tbody></table></div>
<p><img src="/mdimages/image-20210613144430983.png" alt="image-20210613144430983"></p>
<p>其中SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然.</p>

        <h4 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4>
      <ul>
<li>生产者消费者模式</li>
<li>线程池</li>
<li>消息中间件</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
