<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello-World</title>
    <url>/2021/06/08/Hello-World/</url>
    <content><![CDATA[
        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
      
        <h3 id="创建一个文档"   >
          <a href="#创建一个文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个文档" class="headerlink" title="创建一个文档"></a>创建一个文档</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="创建一个页面"   >
          <a href="#创建一个页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;new my pageName&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="生成静态页面至public目录"   >
          <a href="#生成静态页面至public目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>


        <h3 id="部署到GitHub"   >
          <a href="#部署到GitHub" class="heading-link"><i class="fas fa-link"></i></a><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<span id="more"></span>


        <h3 id="清理public目录的内容"   >
          <a href="#清理public目录的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理public目录的内容" class="headerlink" title="清理public目录的内容"></a>清理public目录的内容</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></div></figure>


        <h3 id="指令缩写"   >
          <a href="#指令缩写" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo n    （hexo new）</span><br><span class="line">$ hexo g    （hexo generate）</span><br><span class="line">$ hexo d    （hexo deploy）</span><br></pre></td></tr></table></div></figure>


        <h3 id="组合指令"   >
          <a href="#组合指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合指令" class="headerlink" title="组合指令"></a>组合指令</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">$ hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Hexo常用指令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Top</title>
    <url>/2021/06/08/Linux-Top/</url>
    <content><![CDATA[
        <h1 id="Linux命令之Top"   >
          <a href="#Linux命令之Top" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux命令之Top" class="headerlink" title="Linux命令之Top"></a>Linux命令之Top</h1>
      <p><img src="/mdimages/image-20210527113329108.png" alt="image-20210527113329108"></p>

        <h3 id="第一行，任务队列信息，同uptime命令的执行结果"   >
          <a href="#第一行，任务队列信息，同uptime命令的执行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一行，任务队列信息，同uptime命令的执行结果" class="headerlink" title="第一行，任务队列信息，同uptime命令的执行结果"></a>第一行，任务队列信息，同uptime命令的执行结果</h3>
      <p>系统时间：11:32:32</p>
<p>运行时间：up 61 days, 23:26</p>
<p>当前登录用户：1 user</p>
<p>负载均衡（uptime）：load average:  1.35, 1.25, 1.29</p>
<p>​                                  average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>（load average数据是每隔5秒检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5，就表明系统在超负荷运转）</p>
<span id="more"></span>


        <h3 id="第二行，Tasks-任务（进程）"   >
          <a href="#第二行，Tasks-任务（进程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二行，Tasks-任务（进程）" class="headerlink" title="第二行，Tasks - 任务（进程）"></a>第二行，Tasks - 任务（进程）</h3>
      <p>总进程：231total，运行：2 running，休眠：229 sleeping，停止：0 stopped，僵尸进程：0 zombie</p>

        <h3 id="第三行，cpu状态信息"   >
          <a href="#第三行，cpu状态信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三行，cpu状态信息" class="headerlink" title="第三行，cpu状态信息"></a>第三行，cpu状态信息</h3>
      <p>15.2%us【user space】— 用户空间占用CPU的百分比。</p>
<p>4.9%sy 【sysctl】— 内核空间占用CPU的百分比。</p>
<p>0.0%ni  — 改变过优先级的进程占用CPU的百分比。</p>
<p>79.8%id 【idolt】 — 空闲CPU百分比。</p>
<p>0.0%wa 【wait】 — IO等待占用CPU的百分比。</p>
<p>0.0%hi 【Hardware IRQ】— 硬中断占用CPU的百分比。</p>
<p>0.2%si 【Software Interrupts】— 软中断占用CPU的百分比。</p>
<p>0.0%st 【】</p>

        <h3 id="第四行，内存状态-Mem"   >
          <a href="#第四行，内存状态-Mem" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四行，内存状态-Mem" class="headerlink" title="第四行，内存状态 Mem"></a>第四行，内存状态 Mem</h3>
      <p>8060540k total  总内存大小, 6989544k used 已使用内存大小, 1070996k free 空闲内存大小, 1143720k buffers 【缓存的内存量】</p>

        <h3 id="第五行，swap交换分区信息"   >
          <a href="#第五行，swap交换分区信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五行，swap交换分区信息" class="headerlink" title="第五行，swap交换分区信息"></a>第五行，swap交换分区信息</h3>
      <p>8208380k total 总内存大小, 942352k used 已使用内存大小,  7266028k free 空闲内存大小, 3101300k cached 【缓冲的交换区总量】</p>
<p>补充说明：可用内存 =  free + buffer + cached</p>
<p>在对内存监控中，时刻注意swap 交换区的 used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，表明真正的内存不够用了。</p>

        <h3 id="第六行，空行"   >
          <a href="#第六行，空行" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h3>
      
        <h3 id="第七行以下：各进程（任务）的状态监控"   >
          <a href="#第七行以下：各进程（任务）的状态监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h3>
      <p>PID —- 进程id</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值，负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p>S — 进程状态。D代表不可中断的睡眠状态；R代表运行；S代表睡眠；T代表跟踪/停止；Z代表僵尸进程。</p>
<p>%CPU — 上次更新到现在CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100 秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<p>以下信息默认没展示:</p>
<p>DATA  —  可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位kb。【简单理解，数据占用的内存，真正的该程序要求的数据空间，是真正在运行中要使用的】。</p>
<p>CODE — 可执行代码占用的物理内存大小，单位kb。</p>
<p>可以通过指令f进入 编排基本视图，这里列出了所有可在top基本视图中显示的进程字段，有带 “ * “ 的并且标注为大写字母的字段是可显示的，没有带 “ * “ 并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以移动上下键到这两个字段，然后按d键选择这两个字段，然后按q退出就可以。【提示：按f进入编排基本视图后，如果想进行进程字段显示顺序做修改，使用上下键移动到该字段，然后按右键（即选中该字段），然后上下键移动到需要的位置即可】</p>
<p><img src="/mdimages/image-20210527204228170.png" alt="image-20210527204228170"></p>
<hr>

        <h3 id="VIRT-virtual-memory-usage-虚拟内存"   >
          <a href="#VIRT-virtual-memory-usage-虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#VIRT-virtual-memory-usage-虚拟内存" class="headerlink" title="VIRT :  virtual memory usage 虚拟内存"></a>VIRT :  virtual memory usage 虚拟内存</h3>
      <p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等</p>
<p>注意：假如进程申请100m的内存，但实际只使用了10m,那么它会申请100m，而不是实际的使用量10m.</p>

        <h3 id="RES-resident-memory-usage-常驻内存（单位kb）"   >
          <a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="heading-link"><i class="fas fa-link"></i></a><a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="headerlink" title="RES  :  resident memory usage 常驻内存（单位kb）"></a>RES  :  resident memory usage 常驻内存（单位kb）</h3>
      <p>1、进程当前使用的内存大小，但不包括swap out</p>
<p>2、包含其他进程的共享</p>
<p>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反</p>
<p>补充说明：<strong>当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT</strong></p>

        <h3 id="SHR-shared-memory-共享内存"   >
          <a href="#SHR-shared-memory-共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#SHR-shared-memory-共享内存" class="headerlink" title="SHR : shared memory 共享内存"></a>SHR : shared memory 共享内存</h3>
      <p>1、除了自身进程的共享内存，也包括其他进行的共享内存</p>
<p>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p>
<p>3、计算某个进程所占物理内存大小公式：RES - SHR</p>
<p>4、swap out后，它将会降下来</p>

        <h3 id="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"   >
          <a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="heading-link"><i class="fas fa-link"></i></a><a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="headerlink" title="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"></a>top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">s ：改变画面更新频率。</span><br><span class="line"></span><br><span class="line">l ：关闭或开启第一行top信息。</span><br><span class="line"></span><br><span class="line">t ：关闭或开启第二行Tasks和第三行Cpus信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">m ：关闭或开启第四行Mem和第五行Swap信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">N ：以PID的大小进行降序排序。</span><br><span class="line"></span><br><span class="line">P：以CPU占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">M：以内存占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">h：显示帮助</span><br><span class="line"></span><br><span class="line">n：设置在进程列表所显示进程的数量</span><br><span class="line"></span><br><span class="line">q：退出top</span><br></pre></td></tr></table></div></figure>




        <h3 id="top命令的使用方法"   >
          <a href="#top命令的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#top命令的使用方法" class="headerlink" title="top命令的使用方法"></a>top命令的使用方法</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">使用格式：top [-] [p] [S] [s] [i] [c]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">p：通过指定监控进程ID来显示某个进程的状态。top -p 进程ID</span><br><span class="line"></span><br><span class="line">S：指定累计模式。</span><br><span class="line"></span><br><span class="line">s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line"></span><br><span class="line">i：使top不显示任何闲置或者僵尸进程。</span><br><span class="line"></span><br><span class="line">c：显示整个命令行而不只是显示命令名称。</span><br></pre></td></tr></table></div></figure>




        <h3 id="Linux查看物理CPU个数、核数、逻辑CPU个数"   >
          <a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><strong>Linux查看物理CPU个数、核数、逻辑CPU个数</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上分配和TLAB</title>
    <url>/2021/06/09/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB/</url>
    <content><![CDATA[
        <h2 id="关于栈上分配和TLAB的理解"   >
          <a href="#关于栈上分配和TLAB的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于栈上分配和TLAB的理解" class="headerlink" title="关于栈上分配和TLAB的理解"></a><strong>关于栈上分配和TLAB的理解</strong></h2>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>在java程序中，new出来的对象时分配在堆空间中的，但是实际的情况是，大部分new出来的对象会进入堆空间中，而并非是全部的对象，其实还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB。</p>

        <h2 id="栈上分配"   >
          <a href="#栈上分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2>
      
        <h4 id="栈上分配是什么？"   >
          <a href="#栈上分配是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配是什么？" class="headerlink" title="栈上分配是什么？"></a>栈上分配是什么？</h4>
      <p>JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上（线程私有，属于栈内存），这样随着方法的调用结束，栈空间的回收就会随着栈上分配的打散后的对象回收掉，不再给GC增加额外的无用负担，从而提升应用程序整体的性能。</p>
<span id="more"></span>


        <h4 id="为什么需要栈上分配？"   >
          <a href="#为什么需要栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要栈上分配？" class="headerlink" title="为什么需要栈上分配？"></a>为什么需要栈上分配？</h4>
      <p>在应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用而开始，方法的调用结束而结束，对于这种对象，就应该考虑将该对象不分配在堆空间中。因为一旦分配在堆空间中，当方法调用结束，没有了引用指向该对象，该对象就需要被GC回收，而如果存在大量的这种情况，对GC来说无疑时一种负担。</p>

        <h4 id="如何开启栈上分配？"   >
          <a href="#如何开启栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启栈上分配？" class="headerlink" title="如何开启栈上分配？"></a>如何开启栈上分配？</h4>
      <p>栈上分配需要的前提：</p>
<p>（1）开启逃逸分析（-XX:+DoEscapeAnalysis）</p>
<p>逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，在Server虚拟机模式下才可以开启（jdk1.6默认开启）</p>
<p>（2）开启标量替换（-XX:+EliminateAllocations）</p>
<p>标量替换的作用是允许将对象根据属性打散后分配在栈上，默认该配置为开启</p>

        <h4 id="如何查看逃逸分析的筛选结果？"   >
          <a href="#如何查看逃逸分析的筛选结果？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何查看逃逸分析的筛选结果？" class="headerlink" title="如何查看逃逸分析的筛选结果？"></a>如何查看逃逸分析的筛选结果？</h4>
      <p>配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果</p>

        <h2 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2>
      
        <h4 id="TLAB是什么？"   >
          <a href="#TLAB是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB是什么？" class="headerlink" title="TLAB是什么？"></a>TLAB是什么？</h4>
      <p>全程叫做：Thread Local Allocation Buffer 即线程本地分配缓存</p>
<p>就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的）。</p>

        <h4 id="为什么需要TLAB？"   >
          <a href="#为什么需要TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要TLAB？" class="headerlink" title="为什么需要TLAB？"></a>为什么需要TLAB？</h4>
      <p>一般来说，对象分配在堆上，而堆是一个全局共享的区域，当多个线程同一时刻操作堆内存分配对象空间时，就需要进行同步，而同步带来的效果就是对象分配效率变差（尽管JVM采用了CAS的形式处理分配失败的情况），但是对于存在竞争激烈的分配场合仍然会导致效率变差。（简而言之：需要TLAB的原因就是提高对象在堆上的分配效率）</p>

        <h4 id="如何开启TLAB？"   >
          <a href="#如何开启TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启TLAB？" class="headerlink" title="如何开启TLAB？"></a>如何开启TLAB？</h4>
      <p>JVM默认开启了TLAB功能，可以使用-XX:+UseTLAB 显示是否开启。</p>

        <h4 id="如何观察TLAB使用情况？"   >
          <a href="#如何观察TLAB使用情况？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何观察TLAB使用情况？" class="headerlink" title="如何观察TLAB使用情况？"></a>如何观察TLAB使用情况？</h4>
      <p>JVM提供了-XX:+PrintTLAB，可以打开跟踪TLAB的使用情况。</p>

        <h4 id="如何调整TLAB默认大小？"   >
          <a href="#如何调整TLAB默认大小？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何调整TLAB默认大小？" class="headerlink" title="如何调整TLAB默认大小？"></a>如何调整TLAB默认大小？</h4>
      <p>-XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小。</p>

        <h2 id="栈上分配和TLAB的对比"   >
          <a href="#栈上分配和TLAB的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配和TLAB的对比" class="headerlink" title="栈上分配和TLAB的对比"></a>栈上分配和TLAB的对比</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">针对点</th>
<th align="center">处于对象分配流程的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈上分配</td>
<td align="center">避免GC无畏负担</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TLAB</td>
<td align="center">加速堆上对象的分配</td>
<td align="center">2</td>
</tr>
</tbody></table></div>

        <h2 id="对象分配流程图"   >
          <a href="#对象分配流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象分配流程图" class="headerlink" title="对象分配流程图"></a>对象分配流程图</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://processon.com/diagraming/609de1d91e08533129c22d0f" >对象分配流程图 - ProcessOn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/mdimages/image-20210514104238560.png" alt="image-20210514104238560"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的强、软、弱、虚引用</title>
    <url>/2021/06/09/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[
        <h1 id="Java对象的强引用、软引用、弱引用、虚引用"   >
          <a href="#Java对象的强引用、软引用、弱引用、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对象的强引用、软引用、弱引用、虚引用" class="headerlink" title="Java对象的强引用、软引用、弱引用、虚引用"></a>Java对象的强引用、软引用、弱引用、虚引用</h1>
      
        <h3 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>
      <p>在Java中，除了基本数据类型外，还有引用数据类型；Java根据其生命周期的长短，将引用分为以下4类：强引用、软引用、弱引用和虚引用。</p>

        <h3 id="基本数据类型"   >
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3>
      <ul>
<li>整数类型(byte、short、int、long)</li>
<li>浮点类型(float、double)</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>

        <h3 id="引用数据类型"   >
          <a href="#引用数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3>
      <ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
<span id="more"></span>


        <h3 id="基本数据类型图"   >
          <a href="#基本数据类型图" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型图" class="headerlink" title="基本数据类型图"></a>基本数据类型图</h3>
      <p><img src="/mdimages/image-20210609235746769.png" alt="image-20210609235746769"></p>

        <h3 id="引用类图"   >
          <a href="#引用类图" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类图" class="headerlink" title="引用类图"></a>引用类图</h3>
      <p><img src="/mdimages/image-20210610000110261.png" alt="image-20210610000110261"></p>

        <h3 id="一、强引用（默认支持模式）"   >
          <a href="#一、强引用（默认支持模式）" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、强引用（默认支持模式）" class="headerlink" title="一、强引用（默认支持模式）"></a>一、强引用（默认支持模式）</h3>
      <p>把一个对象赋给一个引用变量，这个引用变量就是一个强引用。(如：Object obj = new Object()中的obj就是强引用)。</p>
<p>即通过关键字new创建的对象所关联的引用就是强引用，此时它处于可达状态（如果不懂可达状态的概念，可参阅GCRoots相关知识），当JVM内存空间不足时，JVM宁愿抛出OOM运行时错误使程序终止，也不会回收“存活”对象来解决内存不足的问题。因此强引用是造成java内存泄漏的主要原因之一。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为Null，一般认为就是可以被垃圾收集的了（具体回收时机要看垃圾收集策略）。</p>
<p>知识补充：当一个对象处于可达状态时，jvm会对其标记为存活对象。</p>

        <h3 id="二、软引用"   >
          <a href="#二、软引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h3>
      <p>软引用是一种相对于强引用弱化一些的引用，需要用java.lang.ref.SoftReference类来实现。</p>
<p>对于只要软引用的对象来说，当系统内存充足时，它不会被回收，当系统内存不足时，它会被回收。</p>
<p>软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中，后续可以调用ReferenceQueue的poll()方法来检查是否有它所关联的对象被回收。如果队列为空，将返回一个null，否则返回队列中前面的一个Reference对象。</p>

        <h4 id="应用场景："   >
          <a href="#应用场景：" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>  软引用通常用在对内存敏感的程序中，比如高速缓存就使用了软引用，内存足够时就保留，不足够时就回收。如MyBatis中就用到。</p>

        <h4 id="代码演示："   >
          <a href="#代码演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">        <span class="comment">//这里将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建大对象数组30M</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;软引用==&gt;&quot;</span>+reference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<p><img src="/mdimages/image-20210611004111118.png" alt="image-20210611004111118"></p>
<p>设置JVM参数：-Xms10m -Xmx10m -XX:+PrintGCDetails（初始化堆内存大小，堆内存最大大小，开启GC回收日志）</p>
<p><img src="/mdimages/image-20210611004543872.png" alt="image-20210611004543872"></p>
<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;956K(9728K), <span class="number">0.0008888</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1372K-&gt;504K(2560K)] 1825K-&gt;1044K(9728K), <span class="number">0.0010868</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 504K-&gt;488K(2560K)] 1044K-&gt;1068K(9728K), <span class="number">0.0009916</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 488K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 580K-&gt;976<span class="title">K</span><span class="params">(7168K)</span>] 1068K-&gt;976<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0093101 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 976K-&gt;976K(9728K), <span class="number">0.0004390</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 976K-&gt;958<span class="title">K</span><span class="params">(7168K)</span>] 976K-&gt;958<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0095406 secs] [Times: user</span>=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">软引用==&gt;<span class="keyword">null</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 61K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">3</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f700</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 958K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">13</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff6efa08</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3554K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 391<span class="title">K</span>, <span class="title">capacity</span> 394<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Exception</span> <span class="title">in</span> <span class="title">thread</span> &quot;<span class="title">main</span>&quot; <span class="title">java</span>.<span class="title">lang</span>.<span class="title">OutOfMemoryError</span>: <span class="title">Java</span> <span class="title">heap</span> <span class="title">space</span></span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">mybatis</span>.<span class="title">Main</span>.<span class="title">main</span>(<span class="title">Main</span>.<span class="title">java</span>:12)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 1</span></span><br></pre></td></tr></table></div></figure>

<p>发现当内存不够的时候软引用对象就会被回收。</p>

        <h3 id="三、弱引用"   >
          <a href="#三、弱引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h3>
      <p>弱引用需要通过java.lang.ref.WeakReference类实现。生命周期比软引用更短。</p>
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都将回收该对象占用的内存。</p>
<p>弱引用还可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，JVM就会把这个弱引用加入与之关联的引用队列中。</p>

        <h4 id="应用场景：-1"   >
          <a href="#应用场景：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>弱引用同样可用于内存敏感的缓存。</p>
<p>弱引用适合解决某些地方的内存泄露问题，比如ThreadLocal，ThreadLocal静态内部类ThreadLocalMap中的Entiry中的key就是一个虚引用。</p>

        <h4 id="代码演示：-1"   >
          <a href="#代码演示：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;强引用对象====&gt;&quot;</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象====&gt;&quot;</span>+weakReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//手动触发垃圾回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========GC回收后的结果==========&quot;</span>);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">强引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">弱引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">==========GC回收后的结果==========</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="补充WeakHashMap"   >
          <a href="#补充WeakHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充WeakHashMap" class="headerlink" title="补充WeakHashMap"></a>补充WeakHashMap</h4>
      <p>WeakHashMap的键是”弱键”，也就是键的引用是一个弱引用。</p>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">7</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;<span class="comment">//这里将key置为null，让其不存在强引用</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map+<span class="string">&quot;===&gt;&quot;</span>+map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;&#125;===&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="四、虚引用"   >
          <a href="#四、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h3>
      <p>虚引用需要java.lang.ref.PhantomReference类实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用，也不能通过它访问对象，必须和引用队列(ReferenceQueue)联合使用。</p>
<p>主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。PhantomReference的get方法总是返回null,无论在GC前还是GC后，PhantomReference在GC前poll方法是null，GC后poll方法是获取被回收的对象，设置虚引用关联的唯一目的就是在这个对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步的处理（类似SpringAop的后置通知）。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>Java允许使用finalize()方法在垃圾回收器将对象从内存中清除出去之前做必要的清理工作。</p>

        <h4 id="应用场景：-2"   >
          <a href="#应用场景：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>可用来跟踪对象被垃圾回收器回收的时候添加一些处理。</p>

        <h4 id="代码演示：-2"   >
          <a href="#代码演示：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <p>对象无重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//这里睡0.1秒确保GC线程执行完再打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;在打印看看&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">第一次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line">在打印看看<span class="keyword">null</span></span><br></pre></td></tr></table></div></figure>

<p>注意：</p>
<p>ReferenceQueue.poll()方法调用拿到对象后，再调用就无该对象了。</p>
<p>代码演示：</p>
<p>对象重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC之后&quot;</span>+queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC要把我清除了/(ㄒoㄒ)/~~......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">GC要把我清除了/(ㄒoㄒ)/~~......</span><br><span class="line">第一次GC之后<span class="keyword">null</span></span><br><span class="line">第二次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="结论"   >
          <a href="#结论" class="heading-link"><i class="fas fa-link"></i></a><a href="#结论" class="headerlink" title="结论"></a>结论</h4>
      <p>对于虚引用，如果被引用的对象没有重写finalize方法，那么在第一次垃圾回收将该对象销毁之后，就会将虚引用对象添加到引用队列中。如果被引用的对象重写了finalize方法，那么则是在执行完第二次垃圾回收后，才将虚引用对象添加到其关联的引用队列中。</p>

        <h4 id="ReferenceQueue引用队列"   >
          <a href="#ReferenceQueue引用队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReferenceQueue引用队列" class="headerlink" title="ReferenceQueue引用队列"></a>ReferenceQueue引用队列</h4>
      <p>对象在被回收之前要被引用队列保存一下。GC之前对象不放在队列中，GC之后对象才放入队列中。</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <ul>
<li>强引用是不会被垃圾回收器随意回收的，也是造成java内存溢出的主要原因之一。</li>
<li>软引用是通过java.lang.ref.SoftReference类来实现，当JVM内存不足时，便会回收软引用所引用的对象。</li>
<li>弱引用是通过java.lang.ref.WeakReference类来实现，只要垃圾回收器回收垃圾时，无论内存足不足够都会把弱引用回收掉。</li>
<li>虚引用是通过java.lang.ref.PhantomReference类来实现，若一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPool线程池</title>
    <url>/2021/06/11/ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[
        <h1 id="ThreadPool线程池"   >
          <a href="#ThreadPool线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1>
      
        <h3 id="线程池是什么"   >
          <a href="#线程池是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3>
      <p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后再创建线程后自动启动这些任务。</p>

        <h3 id="为什么用线程池"   >
          <a href="#为什么用线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3>
      <p>线程池的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务执行。</p>
<p>主要的特点是：线程复用；控制最大并发数；管理线程。</p>
<p>好处：</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<span id="more"></span></li>
</ol>

        <h3 id="线程池如何使用"   >
          <a href="#线程池如何使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h3>
      <p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类。</p>
<p>类图：</p>
<p><img src="/mdimages/image-20210611153209223.png" alt="image-20210611153209223"></p>
<p>Java通过Executors提供了以下几种线程池：</p>
<ul>
<li><p>Executors.newScheduledThreadPool(int corePoolSize);创建一个支持定时以及周期性执行任务的线程池。</p>
</li>
<li><p>Executors.newWorkStealingPool(int);JDK8新增，使用目前机器上可用的处理器作为它的并行级别。</p>
</li>
<li><p>Executors.newFixedThreadPool(int);创建一个定长的线程池，可控制线程最大并发数，超过的线程会在队列中等待。</p>
</li>
<li><p>Executors.newSingleThreadExecutor();创建只有一个线程的线程池，保证所有任务按照FIFO执行；</p>
</li>
<li><p>Executors.newCachedThreadPool();创建一个可缓存线程池；</p>
<p>以上线程池除了newWorkStealingPool底层是使用ForkJoinPool创建外，其它线程池都是使用ThreadPoolExecutor创建的。</p>
</li>
</ul>

        <h4 id="重点介绍："   >
          <a href="#重点介绍：" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点介绍：" class="headerlink" title="重点介绍："></a>重点介绍：</h4>
      <ol>
<li><p>newFixedThreadPool(int)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;====&gt;&quot;</span>+finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为线程池大小为<span class="number">3</span>，每个任务输出finalI后sleep2秒，可以看到每两秒打印<span class="number">3</span>个数字，并且每两秒始终打印的都是三个线程轮流工作。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newSingleThreadExecutor()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO【先进先出】,LIFO【后进先出】,优先级)执行。</li>
<li>newSingleThreadExecutor创建的线程池corePoolSize和maximimPoolSize都设置为1,它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为newSingleThreadExecutor线程池中始终只有一个工作线程工作，所以可以看到工作的线程始终是同一个。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newCachedThreadPool()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newCachedThreadPool将corePooleSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用的阻塞队列是SynchronousQueue，也即是任务来了就创建线程运行，当线程空闲超过60秒就销毁线程。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//始终保持执行第二个任务的时候第一个任务已经完成</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>* finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cachedThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">从底层可以看出newCachedThreadPool创建的线程池为无线大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newScheduledThreadPool(int corePoolSize)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<p>创建一个周期线程池，支持定时及周期性任务执行。</p>
<p>代码演示1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;delay.....延迟3秒&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//等待任务执行完再关闭</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        <span class="comment">//无论任务是否执行完都立马关闭</span></span><br><span class="line">        <span class="comment">//scheduledThreadPool.shutdownNow();</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程执行..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">main线程执行..........</span><br><span class="line">delay.....延迟<span class="number">3</span>秒</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<p>代码演示2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">04</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">07</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">10</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">13</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">16</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">19</span> CST <span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br><span class="line">表示延迟<span class="number">3</span>秒后每<span class="number">3</span>秒执行一次任务。</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h3 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3>
      
        <h4 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="七大参数说明"   >
          <a href="#七大参数说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#七大参数说明" class="headerlink" title="七大参数说明"></a>七大参数说明</h4>
      <ol>
<li>corePoolSize：线程池中的常驻核心线程数。</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数量，此值必须大于1。</li>
<li>keepAliveTime：多余的空闲线程的存活时间。当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。</li>
<li>unit：keepAliveTime的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。</li>
<li>handler：拒接策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时如何来拒接。</li>
</ol>

        <h4 id="线程池的工作原理"   >
          <a href="#线程池的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h4>
      <ol>
<li>在创建了线程池后，等待提交过来的任务请求。</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做如下判断：</li>
</ol>
<p>​      2.1.如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p>
<p>​      2.2.如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p>
<p>​      2.3.如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p>​      2.4.如果队列满了且正在运行的线程数大于或等于mamimumPoolSize，那么线程池会启动饱和拒接策略来执行；</p>
<p>  3.当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
<p>  4.当一个线程无事可做超过一定时间(keepAliveTime)时，线程池会判断：</p>
<p>​     如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。最后线程池的所有任务完成后它最终会收缩到corePoolSize的大小。</p>

        <h4 id="线程池的拒接策略"   >
          <a href="#线程池的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略" class="headerlink" title="线程池的拒接策略"></a>线程池的拒接策略</h4>
      
        <h5 id="线程池的拒接策略是什么"   >
          <a href="#线程池的拒接策略是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略是什么" class="headerlink" title="线程池的拒接策略是什么"></a>线程池的拒接策略是什么</h5>
      <p>等待队列已经排满了，再也塞不进新任务，同时线程池中的maximumPoolSize也达到了，无法进行为新任务服务，这个时候就需要拒接策略机制合理的处理这个问题。</p>

        <h5 id="JDK内置的拒接策略"   >
          <a href="#JDK内置的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#JDK内置的拒接策略" class="headerlink" title="JDK内置的拒接策略"></a>JDK内置的拒接策略</h5>
      <ul>
<li><p>AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行。</p>
</li>
<li><p>CallerRunsPolicy：”调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p>
</li>
<li><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列尝试再次提交当前任务。</p>
</li>
<li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案。</p>
<p> 以上内置拒接策略均实现了RejectedExecutionHandler接口。</p>
</li>
</ul>
<p><img src="/mdimages/image-20210612141336672.png" alt="image-20210612141336672"></p>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>
      <p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p>
<p>Executors返回的线程池对象的弊端如下：</p>
<ol>
<li><p>newFixedThreadPool和newSingleThreadPool：</p>
<p>允许的请求队列长度为Integer.MAX_VALUE,长度约为21亿左右，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p>newCachedThreadPool和newScheduledThreadPool:</p>
<p>允许的创建最大线程数量为Integer.MAX_VALUE,长度约为21亿左右，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ol>

        <h3 id="自定义线程池核心线程数的考量"   >
          <a href="#自定义线程池核心线程数的考量" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义线程池核心线程数的考量" class="headerlink" title="自定义线程池核心线程数的考量"></a>自定义线程池核心线程数的考量</h3>
      <ul>
<li><p>CPU密集型</p>
<p>任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量。</p>
<p>参考公式：CPU核数+1个线程</p>
</li>
<li><p>IO密集型</p>
<p>任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力，浪费在等待。</p>
<p>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>参考公式：CPU核数/1-阻塞系数      阻塞系数在0.8~0.9之间</p>
<p>比如8核CPU：8/1-0.9=80个线程数</p>
</li>
<li><p>CPU核数计算</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(processors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="知识补充"   >
          <a href="#知识补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2>
      
        <h3 id="阻塞队列"   >
          <a href="#阻塞队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3>
      
        <h4 id="阻塞队列的概念"   >
          <a href="#阻塞队列的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列的概念" class="headerlink" title="阻塞队列的概念"></a>阻塞队列的概念</h4>
      <p>阻塞队列它是一种队列，是一种数据结构，阻塞队列在数据结构中所起的作用如下图所示：</p>
<p><img src="/mdimages/image-20210613135406120.png" alt="image-20210613135406120"></p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li>
<li>当阻塞队列时满时，往队列里添加元素的操作将会被阻塞。</li>
<li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它的线程往空的队列插入新的元素。</li>
<li>视图往已满的阻塞队列中添加元素的线程同样也会被阻塞，直到其它线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来后才继续新增。</li>
</ul>

        <h4 id="使用阻塞队列的好处"   >
          <a href="#使用阻塞队列的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用阻塞队列的好处" class="headerlink" title="使用阻塞队列的好处"></a>使用阻塞队列的好处</h4>
      <p>在多线程环境下，所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤醒。</p>
<p>而使用阻塞队列(BlockingQueue)，不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些操作都交给阻塞队列处理。</p>
<p>在JDK1.5前，在多线程环境下，我们都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，会给我们的程序带来不小的复杂度。</p>

        <h4 id="BlockingQueue的核心方法"   >
          <a href="#BlockingQueue的核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">pull(time,unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">抛出异常</td>
<td align="left">当阻塞队列满时，再往队列里add插入元素会抛出java.lang.IllegalStateException: Queue full；<br />当阻塞队列空时，在往队列里remove移除元素会抛出NoSuchElementException;</td>
</tr>
<tr>
<td align="center">特殊值</td>
<td align="left">插入方法offer(e)，成功返回true，失败返回false；<br />移除方法poll()，成功返回出队列的元素，队列里面没有就返回null;</td>
</tr>
<tr>
<td align="center">一直阻塞</td>
<td align="left">当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或者响应中断退出；<br />当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用；</td>
</tr>
<tr>
<td align="center">超时退出</td>
<td align="left">当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出；<br />当阻塞队列空时，队列会阻塞消费者线程一定时间，超过限时后消费者线程会退出；</td>
</tr>
</tbody></table></div>
<p><img src="/mdimages/image-20210613144430983.png" alt="image-20210613144430983"></p>
<p>其中SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然.</p>

        <h4 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4>
      <ul>
<li>生产者消费者模式</li>
<li>线程池</li>
<li>消息中间件</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2021/06/14/ThreadLocal/</url>
    <content><![CDATA[
        <h3 id="ThreadLocal"   >
          <a href="#ThreadLocal" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>多线程访问同一个共享变量容易出现并发问题，特别是多个线程需要对一个共享变量进行写入的时候，为了保证线程安全，一般需要在访问共享变量的时候进行适当的同步(加锁)。</p>

        <h4 id="ThreadLocal是什么"   >
          <a href="#ThreadLocal是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4>
      <p>从JDK1.2的版本开始就提供了java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量副本，从而避免了线程安全问题。</p>
<span id="more"></span>


        <h4 id="ThreadLocal代码演示"   >
          <a href="#ThreadLocal代码演示" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal代码演示" class="headerlink" title="ThreadLocal代码演示"></a>ThreadLocal代码演示</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; num = ThreadLocal.withInitial(()-&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num.set(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        resource.setNum();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程：&quot;</span>+resource.getNum());</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程：&quot;</span>+resource.getNum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">A线程：<span class="number">1</span></span><br><span class="line">main线程：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<p>结论</p>
<p>多个线程操作共享变量互不干扰。</p>

        <h4 id="ThreadLocal的数据结构"   >
          <a href="#ThreadLocal的数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a>ThreadLocal的数据结构</h4>
      <p><img src="/mdimages/image-20210614234128613.png" alt="image-20210614234128613"></p>
<p>Thread类中有一个类型为ThreadLocal.ThreadLocalMap的成员变量（实例变量）threadLocals，也就是说每个线程都有一个自己的ThreadLocalMap.</p>
<p>ThreadLocalMap是ThreadLocal类中的一个静态内部类，内部维护着一个Entry[] table，可以简单地认为key是ThreadLocal，value就是set方法放入的值(而实际上key并不是ThreadLocal本身，而是它的一个弱引用)。</p>
<p>每个线程在往ThreadLocal放值的时候，都会往自己的ThreadLocalMap里存放值，读数据的时候也是以ThreadLocal作为key，在ThreadLocalMap里找对应的值，从而实现线程隔离。</p>
<p>ThreadLocalMap有点类似HashMap的结构，只是HashMap是由数组+链表(或红黑树)实现的，而ThreadLocalMap中没有链表结构。</p>

        <h4 id="ThreadLocal-set-方法原理"   >
          <a href="#ThreadLocal-set-方法原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal-set-方法原理" class="headerlink" title="ThreadLocal.set()方法原理"></a>ThreadLocal.set()方法原理</h4>
      <p>源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">      ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//从当前线程中获取ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//如果ThreadLocalMap为null则创建，否则进行ThreadLocalMap的set方法</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重点在ThreadLocalMap的set方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//通过key计算在散列表中的对应位置</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  </span><br><span class="line">     <span class="comment">//遍历当前key值对应的槽中Entry数据为空，则说明散列数组这里没有数据冲突，跳出for循环，直接set数据到对应的槽中</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">       <span class="comment">//进入循环体，说明key值对应的槽中Entry数据不为空</span></span><br><span class="line">         <span class="comment">//如果槽中已存在的Entry的key值即k == key(也即是说是同个ThreadLocal)，那么set操作就是一个替换操作，做替换逻辑，直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//如果槽中已存在的Entry的key值即k == null,说明当前槽位的Entry是过期数据，执行replaceStaleEntry()替换过期数据方法，然后返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//来到这里，说明key值对应的槽中Entry数据为null，那么直接创建一个新的Entry对象指向对应的槽位</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="comment">//执行++size操作，设置ThreadLocalMap的长度</span></span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">//调用cleanSomeSlots做一次启发式清理工作，清理散列数组中Entry的key过期的数据</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         <span class="comment">//如果清理完成，未清理任何数据，且size大于等于阈值（数组长度的2/3，一开始是16*2/3等于10），则进行rehash()操作</span></span><br><span class="line">         <span class="comment">//rehash中会先进行一轮探测式清理，清理过期key，清理完成后如果size &gt;= threshold - threshold / 4,就会执行扩容resize()。</span></span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用expungeStaleEntries做一次探测式清理工作</span></span><br><span class="line">     expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">     <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">         resize();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>总结：ThreadLocal的set方法，重点在ThreadLocalMap的set方法。</p>
<ol>
<li>首先计算当前set进来的threadLocal（key）在散列表中的对应位置，然后判断该槽位的Entry数据是否为空，如果为空说明散列数组没有数据冲突，跳出循环，直接set数据到对应的槽位中；</li>
<li>如果该槽位Entry数据不为空，那么首先判断该槽位的key值和set进来的key值是否相同，如果相同说明是一个替换操作，做替换逻辑然后直接返回；</li>
<li>如果不相同，接下来先判断该槽位的key是否为null，如果等于null，说明该槽位的Entry是过期数据，则执行替换过期数据逻辑，然后返回；</li>
<li>整个循环执行完毕后，继续往下执行说明向后迭代的过程中遇到了Entry为null的情况，那么直接新建一个Entry指向该槽位，然后设置threadLocalMap的长度加1；</li>
<li>然后做一次cleanSomeSlots启发式清理工作，清理散列数组中Entry的key过期的数据；</li>
<li>如果清理工作完成后，未清理到任何数据，且threadLocalMap的长度size超过了阈值(数组长度的2/3)，则进行rehash（）操作；</li>
<li>rehash（）中会先进行一轮探测式清理，清理过期key的数据，清理完成后如果threadLocalMap的长度size &gt;= threshold - threshold / 4(即大于等于3/4*threshold),那么就执行真正的扩容逻辑resize();</li>
</ol>

        <h4 id="ThreadLocal-get-方法原理"   >
          <a href="#ThreadLocal-get-方法原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal-get-方法原理" class="headerlink" title="ThreadLocal.get()方法原理"></a>ThreadLocal.get()方法原理</h4>
      <p>源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">//从当前线程中获取ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据当前ThreadLocal实例查询其对应的Entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果map为null，则执行setInitialValue()方法</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//通过key计算在散列表中的对应位置（即索引）</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="comment">//如果槽位Entry不为null并且该Entry.key和查找的key一致，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="comment">//如果槽位Entry不为null，但该Entry.key和查找的key不一致</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先获取当前槽位的key值；</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//如果当前槽位key值（k） 和 查找的key值一致，则返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">//如果当前的槽位key值（k）为null，则进行一次探测式数据清理</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//如果当前的槽位key值（k）不为null，则获取下一槽位的索引</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                <span class="comment">//根据获取到的下一槽位的索引，查询对应的槽位Entry</span></span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前key对应的槽位Entry为null，那么直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没重写initialValue方法那么直接返回null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>总结：ThreadLocal的get方法，重点在ThreadLocalMap的getEntry方法。</p>
<ol>
<li><p>首先通过查找key值（threadLocal）计算出散列表中的槽位，如果槽位的Entry为null，那么直接返回null；</p>
</li>
<li><p>如果不为null，那么判断该槽位的Entry的key和查找的key是否一致，如果一致则直接返回；</p>
</li>
<li><p>如果该槽位key值为null，那么进行一次探测式数据清理；</p>
</li>
<li><p>如果不为null，则获取下一槽位的Entry继续对比；</p>
</li>
<li><p>直到整个散列表数组对比完都没匹配上，那么同样返回null；</p>
</li>
</ol>

        <h4 id="ThreadLocalMap的Hash算法"   >
          <a href="#ThreadLocalMap的Hash算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap的Hash算法" class="headerlink" title="ThreadLocalMap的Hash算法"></a>ThreadLocalMap的Hash算法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></div></figure>

<p>ThreadLocalMap中的hash算法很简单，最关键的就是threadLocalHashCode 值的计算，ThreadLocal中有一个属性HASH_INCREMENT = 0x61c88647，这个值很特殊，它是斐波那契数也叫黄金分割数。每当创建一个ThreadLocal对象，这个ThreadLocal.nextHashCode这个值就会增长 0x61c88647。</p>

        <h4 id="ThreadLocalMap如何处理Hash冲突"   >
          <a href="#ThreadLocalMap如何处理Hash冲突" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap如何处理Hash冲突" class="headerlink" title="ThreadLocalMap如何处理Hash冲突"></a>ThreadLocalMap如何处理Hash冲突</h4>
      <p>虽然ThreadLocalMap中使用了黄金分割数来作为hash计算因子，大大减少了Hash冲突的概率，但是仍然会存在冲突。当遇到冲突的时候，ThreadLocalMap就会线性向后查找，一直找到Entry为null的槽位才会停止查找，将当前元素放入此槽位中。当在迭代过程中遇到Entry不为null且key值相等的情况，那么直接替换，如果Entry中的key为null，那么就会执行一次探测式清理数据操作。</p>

        <h4 id="ThreadLocalMap过期key的启发式清理和探测式清理"   >
          <a href="#ThreadLocalMap过期key的启发式清理和探测式清理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap过期key的启发式清理和探测式清理" class="headerlink" title="ThreadLocalMap过期key的启发式清理和探测式清理"></a>ThreadLocalMap过期key的启发式清理和探测式清理</h4>
      <ul>
<li><p>启发式清理，也就是cleanSomeSlots方法，是以当前Entry往后清理，遇到值为null则结束清理，属于线性探测清理。</p>
</li>
<li><p>探测式清理，也就是expungeStaleEntry方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的Entry设置为null，沿途中碰到未过期的数据则将此数据rehash后重新在table数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放在最靠近此位置的Entry=null的桶中，使rehash后Entry数据距离正确的桶的位置更近一些。</p>
</li>
</ul>

        <h4 id="ThreadLocalMap扩容机制"   >
          <a href="#ThreadLocalMap扩容机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h4>
      <p>在ThreadLocalMap的set()方法最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash（）方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></div></figure>

<p>接下来看rehash()的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>rehash方法首先会进行探测式清理工作，从数组table的起始位置往后清理，清理完成之后，table中可能有一些key为null的Entry数据被清理掉，所以此时通过判断 size &gt;= threshold - threshold / 4 也就是 size &gt;= threshold * 3/4 来决定是否扩容。</p>
<p>所以要清楚，执行rehash()的阈值是 sz &gt;= threshold ，执行真正扩容resize()的阈值是 size &gt;= threshold - threshold / 4。</p>
<p>接着看 resize()方法的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Entry[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">     Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">         Entry e = oldTab[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">             <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, newLen);</span><br><span class="line">                 newTab[h] = e;</span><br><span class="line">                 count++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     setThreshold(newLen);</span><br><span class="line">     size = count;</span><br><span class="line">     table = newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>从源码中可以看出，每次扩容后的容量为原来的2倍，扩容后的table的大小为 oldLen * 2，然后遍历老的散列表，重新计算hash位置，然后放到新的table数组中，如果出现hash冲突则往后找最近的entry为null的槽位，遍历完成之后，oldTab中所有的entry数据都已经放入到新的table中了。重新计算table下一次扩容的阈值。</p>

        <h4 id="ThreadLocal的注意事项"   >
          <a href="#ThreadLocal的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal的注意事项" class="headerlink" title="ThreadLocal的注意事项"></a>ThreadLocal的注意事项</h4>
      <ul>
<li><p>读取到脏数据</p>
<p>线程复用会造成脏数据。由于线程池会复用Thread对象，因此Thread类的成员变量threadLocals也会被复用。如果在线程run()方法中不显示调用remove()清理与线程相关的ThreadLocal信息，并且下一个线程不调用set()设置初始值，就可能get()到上个线程设置的值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(finalI == <span class="number">0</span>) &#123;</span><br><span class="line">                    threadLocal.set(finalI);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;     &quot;</span>+threadLocal.get());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>     <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>     <span class="keyword">null</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>内存泄漏</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有持有外部强引用，那么系统发生GC的时候，这个ThreadLocal就会被回收，导致ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，导致value永远存在无法被回收，出现内存泄漏。</p>
<p>其实，ThreadLocalMap的get、set、remove方法在执行的时候都会清除ThreadLocalMap里面所有key为null的value数据，所以每次用完ThreadLocal后，都要及时显式的调用remove方法清理。</p>
</li>
</ul>

        <h4 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4>
      <ol>
<li>为每个线程分配一个JDBC连接Connection，这样就可以保证每个线程都在各自的Connection上进行数据库的操作，不会出现A线程关了B线程正在使用的Connection;</li>
<li>JDK1.7的SimpleDateFormat不是线程安全的，可以用ThreadLocal来解决；当然JDK1.8开始java.time.format.DateTimeFormatter是线程安全的。</li>
<li>应用于变量在线程间隔离但在方法或类间共享的场景。</li>
</ol>

        <h4 id="思考"   >
          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h4>
      <p>ThreadLocal的key是弱引用，那么在ThreadLocal.get()的时候，发生GC之后，key是否是null？</p>
<p>首先我们回忆一下，使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只持有弱引用，那么就会被回收。</p>
<p>这个问题刚开始看，如果没注意，弱引用，而且还发生垃圾回收，那么肯定会觉得key是null，但是题目中说了在ThreadLocal.get()操作，从源码中可以知道ThreadLocal的get方法是一个实例方法，那么ThreadLocal.get()操作，其实还是有强引用存在的，所以key并不会被回收，也就不会为null。如果我们的强引用不存在的话，那么key就会被回收，也就是会出现value没被回收，而key被回收，导致value永远存在，出现内存泄漏。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JDK1.6及以上版本对synchronized的优化</title>
    <url>/2021/06/21/JDK1.6%E5%BC%80%E5%A7%8Bsynchronized%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[
        <h3 id="概叙"   >
          <a href="#概叙" class="heading-link"><i class="fas fa-link"></i></a><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h3>
      <p>在JDK最开始的时候synchronized属于重量级的锁，每次加锁都是通过操作系统来申请锁，所以导致效率比较低，但在JDK1.6及以上版本中对它进行了优化，为减少获得锁和释放锁带来的性能消耗引入了偏向锁和轻量级锁，以及锁的存储结构和升级过程，不再是一开始就向操作系统申请锁，而是分成偏向锁 - 轻量级锁 - 重量级锁三个过程。</p>

        <h3 id="实现同步的基础"   >
          <a href="#实现同步的基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现同步的基础" class="headerlink" title="实现同步的基础"></a>实现同步的基础</h3>
      <p>Java中的每个对象都可以作为锁。</p>
<ul>
<li>普通同步方法，锁是当前实例对象。</li>
<li>静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是synchronized括号里的对象。</li>
</ul>
<p>一个线程试图访问同步方法或者同步代码块时，必须获取锁，在退出或者抛出异常时，必须释放锁。</p>
<span id="more"></span>


        <h3 id="synchronized的特点"   >
          <a href="#synchronized的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#synchronized的特点" class="headerlink" title="synchronized的特点"></a>synchronized的特点</h3>
      <ul>
<li>原子性，不可分割，要么全部执行成功，要么全部失败</li>
<li>可见性，一个线程对共享变量的修改，其他线程能够立马看见</li>
<li>有序性，代码执行的逻辑是按照编写时的顺序执行的(禁止指令重排)</li>
</ul>

        <h3 id="实现方式"   >
          <a href="#实现方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3>
      <p>synchronized的背后正是利用了Monitor锁对象来实现同步方法和同步代码块，但是两者的实现细节不一样。</p>
<ul>
<li>同步代码块：通过使用monitorenter和monitorexit指令实现。</li>
<li>同步方法：标识ACC_SYNCHRONIZED修饰。</li>
</ul>
<p>同步代码块代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloSynchronized helloSynchronized = <span class="keyword">new</span> HelloSynchronized();</span><br><span class="line">        helloSynchronized.print1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSynchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同步代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同步方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>输入命令 javap -c D:\workproject\MyBatisProject\target\classes\com\test\mybatis\test\HelloSynchronized.class 查看编译后的字节码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分编译后的字节码 </span></span><br><span class="line">Compiled from <span class="string">&quot;HelloSynchronized.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">mybatis</span>.<span class="title">test</span>.<span class="title">HelloSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.mybatis.test.HelloSynchronized();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 同步代码块</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit</span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   <span class="function">any</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String 同步方法</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>同步方法代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloSynchronized helloSynchronized = <span class="keyword">new</span> HelloSynchronized();</span><br><span class="line">        helloSynchronized.print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSynchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同步代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同步方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>输入命令javap -verbose D:\workproject\MyBatisProject\target\classes\com\test\mybatis\test\HelloSynchronized.class查看编译后的字节码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分编译后的字节码  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String 同步方法</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/test/mybatis/test/HelloSynchronized;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>总结：</p>
<p>同步代码块：monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit指令总共出现了2次，第一次是在编译后插入到同步代码块的结束处，第二次是同步代码块的异常处，保证无论正常或者异常退出都能释放锁。</p>
<p>同步方法：被synchronized修饰的方法会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个同步方法时，会先检查方法是否有ACC_SYNCHRONIZED标志，如果有则需要先获得monitor锁才能开始执行方法，执行完后再是否monitor锁。</p>

        <h3 id="在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头，实例数据和对齐填充。"   >
          <a href="#在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头，实例数据和对齐填充。" class="heading-link"><i class="fas fa-link"></i></a><a href="#在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头，实例数据和对齐填充。" class="headerlink" title="在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头，实例数据和对齐填充。"></a>在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头，实例数据和对齐填充。</h3>
      <p><img src="/mdimages/image-20210622002758920.png" alt="image-20210622002758920"></p>

        <h4 id="Java对象头"   >
          <a href="#Java对象头" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4>
      <p>对象头中包含两个部分的信息：Mark Word（运行时数据）和类型指针（Class Pointer）.</p>
<p>如果是数组对象的话，对象头就会多一部分信息是存储数组的长度（Length）.</p>
<p>重点：多线程下synchronized的加锁就是对同一个对象的对象头中的Mark Word中的变量进行CAS操作(下面会详细说明)。</p>

        <h5 id="Mark-Word"   >
          <a href="#Mark-Word" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5>
      <p>Mark Word主要存储对象自身的运行时数据，比如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</p>
<p><img src="/mdimages/image-20210622001658496.png" alt="image-20210622001658496"></p>

        <h5 id="类型指针-Class-Pointer"   >
          <a href="#类型指针-Class-Pointer" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型指针-Class-Pointer" class="headerlink" title="类型指针(Class Pointer)"></a>类型指针(Class Pointer)</h5>
      <p>类型指针用来指向对象对应到的Class对象(其对应的元数据)内存地址，虚拟机通过这个指针确定该对象是哪个类的实例。</p>

        <h5 id="数组长度-Length-数组对象才有"   >
          <a href="#数组长度-Length-数组对象才有" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组长度-Length-数组对象才有" class="headerlink" title="数组长度(Length,数组对象才有)"></a>数组长度(Length,数组对象才有)</h5>
      
        <h4 id="实例数据"   >
          <a href="#实例数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4>
      <p>实例数据才是存储对象真正存储的有效信息（即程序代码中定义的各种类型的字段内容）。</p>
<p>无论是父类继承下来的，还是在子类定义的，都记录下来。</p>

        <h4 id="对齐填充"   >
          <a href="#对齐填充" class="heading-link"><i class="fas fa-link"></i></a><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4>
      <p>这部分不是必然存在的，只是位数不够拿来填充，为了整齐，仅仅起到占位符的作用，因为HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也即是说，对象的大小必须是8字节的整数倍。</p>

        <h3 id="优化后synchronized锁的分类"   >
          <a href="#优化后synchronized锁的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化后synchronized锁的分类" class="headerlink" title="优化后synchronized锁的分类"></a>优化后synchronized锁的分类</h3>
      <ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<p>锁可以升级，但不能降级，即：无锁 - &gt; 偏向锁 - &gt; 轻量级锁 - &gt; 重量级锁 </p>
<p><img src="/mdimages/image-20210622210459247.png" alt="image-20210622210459247"></p>
<p>从上图可以看出，在对象头中的Mark Word中每个锁状态的内容</p>
<p>无锁状态：是否是偏向锁位 是 “0”，锁标志位是 “01”；</p>
<p>偏向锁状态：是否是偏向锁位 是 “1”，锁标志位是 “01”；</p>
<p>轻量级锁状态：指向线程栈中Lock Record的指针，锁标志位是 “00”；</p>
<p>重量级锁状态：指向互斥量(重量级锁)的指针，锁标志位是 “10”；</p>

        <h3 id="偏向锁"   >
          <a href="#偏向锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3>
      <p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，从JDK1.6开始引入了锁优化。偏向锁是针对于一个线程而已的，就是锁偏向于第一个获取它的线程，如果在接下来的执行过程中，该锁没有被其它的线程获取，则持有偏向锁的线程将不需要再进行同步了。</p>

        <h4 id="偏向锁的加锁"   >
          <a href="#偏向锁的加锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h4>
      <p>当一个线程访问同步块并获取锁时，会在锁对象的对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要进行CAS操作来加锁解锁，只需要验证一下锁对象的对象头的Mark Word里是否存储着指向当前线程的偏向锁(也既是对象头的Mark Word中的线程ID是当前线程)，如果验证成功，表示线程已经获得了锁；如果验证失败，则需要再判断MarkWord中偏向锁的标识位是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将锁对象的对象头的偏向锁指向当前线程。</p>

        <h4 id="偏向锁的撤销"   >
          <a href="#偏向锁的撤销" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4>
      <p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，偏向锁的撤销需要等到全局安全点(在这个时间点上没有正在执行的字节码)，首先会暂停持有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程不处于活动状态，则将锁对象的对象头设置为无锁状态；如果线程仍然存活，则锁对象的对象头中的Mark Word和栈中的锁记录要么重新偏向于其它线程，要么恢复到无锁状态，最后唤醒暂停的线程(释放偏向锁的线程)。</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
      <p>偏向锁在JDK1.6及更高版本中是默认开启的，但是它在程序启动几秒后才激活，可以使用-XX:BiasedLockingStartupDelay = 0 来关闭偏向锁的启动延迟，也可以使用-XX:-UseBiasedLocking = false 来关闭偏向锁，那么程序会直接进入轻量级锁状态。</p>

        <h3 id="轻量级锁"   >
          <a href="#轻量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3>
      <p>当出现有两个线程来竞争锁的时候，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。</p>

        <h4 id="轻量级锁加锁"   >
          <a href="#轻量级锁加锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4>
      <p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建存储锁记录的空间（LockRecord），并将对象头中的MarkWord复制到锁记录中，然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针，如果成功，当前线程获得锁；如果失败，表示其他线程竞争锁，当前线程便尝试使用CAS自旋来获取锁，之后再来的线程，发现是轻量级锁，就开始进行自旋。</p>
<p>（JDK自旋默认最大值是10次，JDK6开始对自旋进行了优化，自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的，比如当前线程在刚刚成功获取过自旋锁，那么JVM就会认为这次自旋也可能会成功，那么循环的次数就可以多进行几次，这就是自适应自旋，有了自适应自旋就不用我们设置最大循环次数，而是让JVM监控动态设置）。</p>

        <h4 id="轻量级锁解锁"   >
          <a href="#轻量级锁解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4>
      <p>轻量级锁解锁时，会使用原子的CAS操作将当前线程的锁记录替换到对象头，如果成功，表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>

        <h4 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4>
      <p>加锁过程, 有线程A和线程B来竞争对象c的锁(如: synchronized(c){} ), 这时线程A和线程B同时将对象c的MarkWord复制到自己的锁记录中, 两者竞争去获取锁, 假设线程A成功获取锁, 并将对象c的对象头中的线程ID(MarkWord中)修改为指向自己的锁记录的指针, 这时线程B仍旧通过CAS去获取对象c的锁, 因为对象c的MarkWord中的内容已经被线程A改了, 所以获取失败. 此时为了提高获取锁的效率, 线程B会循环去获取锁, 这个循环是有次数限制的, 如果在循环结束之前CAS操作成功, 那么线程B就获取到锁, 如果循环结束依然获取不到锁, 则获取锁失败, 对象c的MarkWord中的记录会被修改为重量级锁, 然后线程B就会被挂起, 之后有线程C来获取锁时, 看到对象c的MarkWord中的是重量级锁的指针, 说明竞争激烈, 直接挂起.</p>
<p>解锁过程, 线程A尝试使用CAS将对象c的MarkWord改回自己栈中复制的那个MarkWord, 因为对象c中的MarkWord已经被指向为重量级锁了, 所以CAS失败. 线程A会释放锁并唤起等待的线程, 进行新一轮的竞争.</p>

        <h3 id="重量级锁"   >
          <a href="#重量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3>
      <p> 重量级锁就是最开始的线程阻塞操作，又叫悲观锁，对象头中MarkWord的锁标志位为10，它锁住的是一整段代码，当整段代码执行完后，其他线程才能获得锁，继续执行。</p>

        <h3 id="锁升级流程图"   >
          <a href="#锁升级流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁升级流程图" class="headerlink" title="锁升级流程图"></a>锁升级流程图</h3>
      <p><img src="/mdimages/image-20210622233415801.png" alt="image-20210622233415801"></p>

        <h3 id="三者的优缺点"   >
          <a href="#三者的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#三者的优缺点" class="headerlink" title="三者的优缺点"></a>三者的优缺点</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适合场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">加锁和解锁不需要额外的消耗，和执行非同步代码方法的性能差不多</td>
<td align="center">如果线程间存在锁竞争，会带来额外锁撤销的消耗</td>
<td align="center">适用于只有一个线程访问的同步场景</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">竞争锁的线程不会阻塞，提高了程序的响应速度</td>
<td align="center">如果始终获取不到锁的线程，会自旋，带来CPU的消耗</td>
<td align="center">追求响应时间，同步快执行速度非常快的场景</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">线程竞争不使用自旋，不会消耗CPU</td>
<td align="center">线程堵塞，响应时间缓慢</td>
<td align="center">追求吞吐量，同步快执行时间速度较长的场景</td>
</tr>
</tbody></table></div>

        <h3 id="锁优化之锁消除"   >
          <a href="#锁优化之锁消除" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁优化之锁消除" class="headerlink" title="锁优化之锁消除"></a>锁优化之锁消除</h3>
      <p>锁消除：锁消除是Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。</p>
<p>当一段代码中加了锁，但是通过JVM分析，他是线程安全的，那么JVM会对这些同步锁进行锁消除，也就是取消加锁操作。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     sb.append(a);                            </span><br><span class="line">     sb.append(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer是线程安全的，其方法都被synchronized修饰，是同步的，JVM会分析sb引用只会在append方法中使用，不可能被其他线程引用(局部变量，属栈私有)，因此sb是不可能共享资源的，JVM会自动消除StringBuffer对象内部的锁。</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="锁优化之锁粗化"   >
          <a href="#锁优化之锁粗化" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁优化之锁粗化" class="headerlink" title="锁优化之锁粗化"></a>锁优化之锁粗化</h3>
      <p>锁粗化：当JVM检测到一段连续的多次操作都在对同一个对象多次加锁，那么JVM可能会优化成对整段加一个锁，没有把加锁的操作分的那么细，所以叫锁粗化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        sb.append(a);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JVM检测分析这一连串的操作都是对同一个对象加锁，循环体中如果没有锁粗化的话那么就要执行100次加锁解锁操作，此时JVM就会将加锁的范围粗化到这一连串的操作的外部(比如for循环体外)，使得这一连串操作只需要加一次锁即可。</span></span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM之逃逸分析</title>
    <url>/2021/06/23/JVM%E4%B9%8B%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
        <h3 id="逃逸"   >
          <a href="#逃逸" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h3>
      <p>当一个对象的指针被多个方法或者线程引用时，我们称这个指针发生了逃逸，一般情况返回对象、对全局变量的赋值一般都会发生逃逸现象。</p>
<p>逃逸分为两种：</p>
<ul>
<li>方法逃逸：当一个对象在方法中被定义后，可能作为调用参数被外部方法所引用。</li>
<li>线程逃逸：通过赋值给类变量或者作为实例变量在其他线程中可以被访问到。</li>
</ul>

        <h3 id="逃逸分析"   >
          <a href="#逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3>
      <p>Java中对象的创建一般会由堆内存去分配内存空间来进行存储，在堆内存空间不足的时候，GC便会对堆内存进行垃圾回收，如果GC运行的次数过多，便会影响程序的性能，所以“逃逸分析”从<font color="red">JDK1.6开始引入</font>，在<font color="red">JDK1.7开始默认开启逃逸分析</font>，它的目的就是判断哪些对象是可以存储在栈内存中而不用存储在堆内存中的，从而让其随着线程的销毁而销毁，进而减少了GC发生的频率。</p>
<span id="more"></span>

<p>简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在Java堆上分配内存的一项技术。</p>
<p>在方法中创建对象之后，如果这个对象除了在方法体中还在其他地方被引用了，此时如果方法执行完，由于该对象有被引用，所以GC有可能是无法立即回收的，此时便成为内存逃逸现象。</p>

        <h3 id="逃逸分析参数设置"   >
          <a href="#逃逸分析参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析参数设置" class="headerlink" title="逃逸分析参数设置"></a>逃逸分析参数设置</h3>
      <ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
</ul>
<p>JDK1.7开始默认开启逃逸分析</p>
<p>代码演示（以主流JDK1.8为准）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让线程好好睡眠</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Thread.sleep(<span class="number">100000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">//使用java -version 查看当前JDK版本</span></span><br><span class="line">D:\workproject\designDemo&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_144&quot;</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_144</span>-b01)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.144</span>-b01, mixed mode)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用jps -l 命令查看java进程号</span></span></span><br><span class="line"><span class="function">D:\workproject\designDemo&gt;jps -l</span></span><br><span class="line"><span class="function">20116</span></span><br><span class="line"><span class="function">18040 sun.tools.jps.Jps</span></span><br><span class="line"><span class="function">11124 com.test.demot.Test</span></span><br><span class="line"><span class="function">2396 org.jetbrains.jps.cmdline.Launcher</span></span><br><span class="line"><span class="function"><span class="comment">//使用jinfo -flag DoEscapeAnalysis 查看是否开启了逃逸分析</span></span></span><br><span class="line"><span class="function">D:\workproject\designDemo&gt;jinfo -flag DoEscapeAnalysis 11124</span></span><br><span class="line"><span class="function">-XX:+DoEscapeAnalysis</span></span><br><span class="line"><span class="function"><span class="comment">//从结果中可以看出 -XX:+DoEscapeAnalysis 是默认开启的</span></span></span><br></pre></td></tr></table></div></figure>


        <h3 id="逃逸分析的作用"   >
          <a href="#逃逸分析的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析的作用" class="headerlink" title="逃逸分析的作用"></a>逃逸分析的作用</h3>
      <p>逃逸分析的作用：就是筛选出没有发生逃逸的对象，从而对它们进行三个方面的优化：（1）<font color="red">锁消除</font>、（2）<font color="red">标量替换</font>、（3）<font color="red">栈内存分配</font></p>

        <h4 id="锁消除（同步消除）"   >
          <a href="#锁消除（同步消除）" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁消除（同步消除）" class="headerlink" title="锁消除（同步消除）"></a>锁消除（同步消除）</h4>
      <p>因为同步锁是非常消耗性能的，所以当编译器确定一个对象没有发生逃逸时，它便会移除该对象的同步锁。</p>
<p>在<font color="red">JDK1.8</font>是默认开启的，但是要建立在已开启逃逸分析的基础上。</p>
<p>开启锁消除：-XX:+EliminateLocks</p>
<p>关闭锁消除：-XX:-EliminateLocks</p>

        <h4 id="标量替换"   >
          <a href="#标量替换" class="heading-link"><i class="fas fa-link"></i></a><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4>
      <p>标量：基础类型和对象的引用可以理解为标量，它们不能被进一步分解。</p>
<p>聚合量：能被进一步分解的就是聚合量，比如：对象。</p>
<p>对象是聚合量，它可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p>
<p>所以，如果一个对象没有发生逃逸，那压根就不用创建它了，只会在栈或者寄存器上创建它用到的成员变量，节省内存空间，也提升应用程序性能。</p>
<p>标量替换在<font color="red">JDK1.8</font>中也是默认开启的，但是同样也要建立在已开启逃逸分析的基础上。</p>
<p>开启标量替换：-XX:+EliminateAllocations</p>
<p>关闭标量替换：-XX:-EliminateAllocations</p>

        <h4 id="栈内存分配（专业术语：栈上分配）"   >
          <a href="#栈内存分配（专业术语：栈上分配）" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈内存分配（专业术语：栈上分配）" class="headerlink" title="栈内存分配（专业术语：栈上分配）"></a>栈内存分配（专业术语：栈上分配）</h4>
      <p>栈内存分配，就是将原本分配在堆内存中的对象转而分配在栈内存上，这样就可以减少堆内存的占用，从而减少GC的频次。</p>

        <h3 id="逃逸分析测试"   >
          <a href="#逃逸分析测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析测试" class="headerlink" title="逃逸分析测试"></a>逃逸分析测试</h3>
      
        <h4 id="逃逸分析开启与关闭测试"   >
          <a href="#逃逸分析开启与关闭测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析开启与关闭测试" class="headerlink" title="逃逸分析开启与关闭测试"></a>逃逸分析开启与关闭测试</h4>
      <p>代码演示：</p>
<p>循环200W次调用createPerson()方法，createPerson()方法的作用仅仅是简单创建一个对象，但是这个对象是属于方法内部的(局部变量)并且没有作为其他方法的调用参数，所以是未逃逸的，理论上JVM是会对其进行优化。下面是开启逃逸分析和关闭逃逸分析之后的比较：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">            createPerson();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        <span class="comment">//让线程好好睡眠1小时，方便对它进行分析</span></span><br><span class="line">        TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//getter seeter方法......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>1、使用JDK1.8环境，JDK1.8是默认开启逃逸分析</p>
<p><img src="/mdimages/image-20210624225703954.png" alt="image-20210624225703954"></p>
<p>从运行结果来看，耗时5毫秒；</p>
<p><img src="/mdimages/image-20210624225805365.png" alt="image-20210624225805365"></p>
<p>使用jmap命令打印堆内存中对象的统计信息，可以看到循环200万次，创建10W个左右的对象；</p>
<p>2、使用JDK1.8环境，JDK1.8是默认开启逃逸分析，所以需要使用命令-XX:-DoEscapeAnalysis来关闭逃逸分析；</p>
<p><img src="/mdimages/image-20210624225617447.png" alt="image-20210624225617447"></p>
<p>从运行结果来看，耗时25毫秒；</p>
<p><img src="/mdimages/image-20210624225530869.png" alt="image-20210624225530869"></p>
<p>使用jmap命令打印堆内存中对象的统计信息，可以看到循环200万次，创建200W个的对象；</p>
<p>小结：无论是从代码的执行时间或者是从堆内存中对象的统计信息来分析，在上述场景下，开启逃逸分析是有性能优化的。</p>

        <h4 id="标量替换开启与关闭测试"   >
          <a href="#标量替换开启与关闭测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#标量替换开启与关闭测试" class="headerlink" title="标量替换开启与关闭测试"></a>标量替换开启与关闭测试</h4>
      <p>代码运行同上，主要通过参数-XX:+EliminateAllocations的开启和关闭来观察效果</p>
<p>1、使用JDK1.8环境，JDK1.8是默认开启标量替换</p>
<p><img src="/mdimages/image-20210624231020275.png" alt="image-20210624231020275"></p>
<p><img src="/mdimages/image-20210624231226837.png" alt="image-20210624231226837"></p>
<p>从运行结果来看，耗时5毫秒，并且堆内存创建的person对象是9万多个；</p>
<p>2、使用JDK1.8环境，JDK1.8是默认开启标量替换，所以需要使用命令-XX:-EliminateAllocations来关闭标量替换；</p>
<p><img src="/mdimages/image-20210624230735372.png" alt="image-20210624230735372"></p>
<p><img src="/mdimages/image-20210624230910677.png" alt="image-20210624230910677"></p>
<p>从运行结果来看，耗时27毫秒，并且堆内存创建的person对象是200万个；</p>
<p>小结：从上述场景我们也可以看出，在开启逃逸分析的基础上，对于标量替换的开启和关闭对于性能的影响也是满大的。</p>

        <h4 id="锁消除开启与关闭测试"   >
          <a href="#锁消除开启与关闭测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁消除开启与关闭测试" class="headerlink" title="锁消除开启与关闭测试"></a>锁消除开启与关闭测试</h4>
      <p>演示代码：</p>
<p><img src="/mdimages/image-20210624233323546.png" alt="image-20210624233323546"></p>
<p>主要通过参数-XX:+EliminateLocks的开启和关闭来观察效果</p>
<p>1、使用JDK1.8环境，JDK1.8是默认开启锁消除</p>
<p><img src="/mdimages/image-20210624233714299.png" alt="image-20210624233714299"></p>
<p><img src="/mdimages/image-20210624234158263.png" alt="image-20210624234158263"></p>
<p>从运行结果和命令参数分析来看，耗时6毫秒，并且默认开启逃逸分析和锁消除；</p>
<p>2、使用JDK1.8环境，JDK1.8是默认开启锁消除，所以需要使用命令-XX:-EliminateLocks来关闭标量替换；</p>
<p><img src="/mdimages/image-20210624234441226.png" alt="image-20210624234441226"></p>
<p><img src="/mdimages/image-20210624234652635.png" alt="image-20210624234652635"></p>
<p>从运行结果和命令参数分析来看，关闭锁消除耗时57毫秒；</p>
<p>小结：同样从以上场景，在开启逃逸分析的前提下，对锁消除的开启和关闭对程序性能的影响也是很大的。</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>总体上逃逸分析可以带来一定程度上的性能优化，但是同时逃逸分析自身也是需要消耗一定的性能去进行一系列复杂的分析的，这其实也是一个相对耗时的过程，所以说如果在方法中的对象全都处于逃逸状态，那么就没有起到优化的作用，从而白白消耗了这部分的性能。</p>

        <h3 id="思考"   >
          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h3>
      <p>是否所有的对象和数组都会在堆内存分配空间？</p>
<p>不一定，JVM经过逃逸分析后，可能会将原本分配在堆内存中的对象转而分配在栈内存上。</p>
<p>加了锁的代码，锁就一定会生效吗？</p>
<p>不一定，JVM经过逃逸分析后，会去除不可能存在共享资源竞争的锁。</p>

        <h3 id="知识补充"   >
          <a href="#知识补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3>
      <p>JAVA中所有的变量分为：（1）成员变量 和（2）局部变量</p>
<p>（1）成员变量包括：</p>
<ul>
<li>实例变量</li>
<li>类变量(static修饰)</li>
</ul>
<p>区别：实例变量是通过定义类的对象来访问的；类变量一般是通过类访问的，也可以用类对象来访问。</p>
<p>生命周期：实例变量与类对象生存周期共存亡；类变量与类共存亡。</p>
<p>（2）局部变量</p>
<ul>
<li>形参（方法参数）</li>
<li>方法局部变量（在方法内定义的变量）</li>
<li>代码块局部变量（在代码块内定义的变量）</li>
</ul>
<p>注：JAVA允许局部变量和成员变量同名，如果在方法内的局部变量和成员变量名相同，局部变量会覆盖成员变量，若要在这个方法里使用成员变量，可以使用this来调用成员变量。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
