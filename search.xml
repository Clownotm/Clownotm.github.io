<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello-World</title>
    <url>/2021/06/08/Hello-World/</url>
    <content><![CDATA[
        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
      
        <h3 id="创建一个文档"   >
          <a href="#创建一个文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个文档" class="headerlink" title="创建一个文档"></a>创建一个文档</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="创建一个页面"   >
          <a href="#创建一个页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;new my pageName&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="生成静态页面至public目录"   >
          <a href="#生成静态页面至public目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>


        <h3 id="部署到GitHub"   >
          <a href="#部署到GitHub" class="heading-link"><i class="fas fa-link"></i></a><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<span id="more"></span>


        <h3 id="清理public目录的内容"   >
          <a href="#清理public目录的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理public目录的内容" class="headerlink" title="清理public目录的内容"></a>清理public目录的内容</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></div></figure>


        <h3 id="指令缩写"   >
          <a href="#指令缩写" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo n    （hexo new）</span><br><span class="line">$ hexo g    （hexo generate）</span><br><span class="line">$ hexo d    （hexo deploy）</span><br></pre></td></tr></table></div></figure>


        <h3 id="组合指令"   >
          <a href="#组合指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合指令" class="headerlink" title="组合指令"></a>组合指令</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">$ hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Hexo常用指令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Top</title>
    <url>/2021/06/08/Linux-Top/</url>
    <content><![CDATA[
        <h1 id="Linux命令之Top"   >
          <a href="#Linux命令之Top" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux命令之Top" class="headerlink" title="Linux命令之Top"></a>Linux命令之Top</h1>
      <p><img src="/mdimages/image-20210527113329108.png" alt="image-20210527113329108"></p>

        <h3 id="第一行，任务队列信息，同uptime命令的执行结果"   >
          <a href="#第一行，任务队列信息，同uptime命令的执行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一行，任务队列信息，同uptime命令的执行结果" class="headerlink" title="第一行，任务队列信息，同uptime命令的执行结果"></a>第一行，任务队列信息，同uptime命令的执行结果</h3>
      <p>系统时间：11:32:32</p>
<p>运行时间：up 61 days, 23:26</p>
<p>当前登录用户：1 user</p>
<p>负载均衡（uptime）：load average:  1.35, 1.25, 1.29</p>
<p>​                                  average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>（load average数据是每隔5秒检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5，就表明系统在超负荷运转）</p>
<span id="more"></span>


        <h3 id="第二行，Tasks-任务（进程）"   >
          <a href="#第二行，Tasks-任务（进程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二行，Tasks-任务（进程）" class="headerlink" title="第二行，Tasks - 任务（进程）"></a>第二行，Tasks - 任务（进程）</h3>
      <p>总进程：231total，运行：2 running，休眠：229 sleeping，停止：0 stopped，僵尸进程：0 zombie</p>

        <h3 id="第三行，cpu状态信息"   >
          <a href="#第三行，cpu状态信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三行，cpu状态信息" class="headerlink" title="第三行，cpu状态信息"></a>第三行，cpu状态信息</h3>
      <p>15.2%us【user space】— 用户空间占用CPU的百分比。</p>
<p>4.9%sy 【sysctl】— 内核空间占用CPU的百分比。</p>
<p>0.0%ni  — 改变过优先级的进程占用CPU的百分比。</p>
<p>79.8%id 【idolt】 — 空闲CPU百分比。</p>
<p>0.0%wa 【wait】 — IO等待占用CPU的百分比。</p>
<p>0.0%hi 【Hardware IRQ】— 硬中断占用CPU的百分比。</p>
<p>0.2%si 【Software Interrupts】— 软中断占用CPU的百分比。</p>
<p>0.0%st 【】</p>

        <h3 id="第四行，内存状态-Mem"   >
          <a href="#第四行，内存状态-Mem" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四行，内存状态-Mem" class="headerlink" title="第四行，内存状态 Mem"></a>第四行，内存状态 Mem</h3>
      <p>8060540k total  总内存大小, 6989544k used 已使用内存大小, 1070996k free 空闲内存大小, 1143720k buffers 【缓存的内存量】</p>

        <h3 id="第五行，swap交换分区信息"   >
          <a href="#第五行，swap交换分区信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五行，swap交换分区信息" class="headerlink" title="第五行，swap交换分区信息"></a>第五行，swap交换分区信息</h3>
      <p>8208380k total 总内存大小, 942352k used 已使用内存大小,  7266028k free 空闲内存大小, 3101300k cached 【缓冲的交换区总量】</p>
<p>补充说明：可用内存 =  free + buffer + cached</p>
<p>在对内存监控中，时刻注意swap 交换区的 used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，表明真正的内存不够用了。</p>

        <h3 id="第六行，空行"   >
          <a href="#第六行，空行" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h3>
      
        <h3 id="第七行以下：各进程（任务）的状态监控"   >
          <a href="#第七行以下：各进程（任务）的状态监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h3>
      <p>PID —- 进程id</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值，负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p>S — 进程状态。D代表不可中断的睡眠状态；R代表运行；S代表睡眠；T代表跟踪/停止；Z代表僵尸进程。</p>
<p>%CPU — 上次更新到现在CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100 秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<p>以下信息默认没展示:</p>
<p>DATA  —  可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位kb。【简单理解，数据占用的内存，真正的该程序要求的数据空间，是真正在运行中要使用的】。</p>
<p>CODE — 可执行代码占用的物理内存大小，单位kb。</p>
<p>可以通过指令f进入 编排基本视图，这里列出了所有可在top基本视图中显示的进程字段，有带 “ * “ 的并且标注为大写字母的字段是可显示的，没有带 “ * “ 并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以移动上下键到这两个字段，然后按d键选择这两个字段，然后按q退出就可以。【提示：按f进入编排基本视图后，如果想进行进程字段显示顺序做修改，使用上下键移动到该字段，然后按右键（即选中该字段），然后上下键移动到需要的位置即可】</p>
<p><img src="/mdimages/image-20210527204228170.png" alt="image-20210527204228170"></p>
<hr>

        <h3 id="VIRT-virtual-memory-usage-虚拟内存"   >
          <a href="#VIRT-virtual-memory-usage-虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#VIRT-virtual-memory-usage-虚拟内存" class="headerlink" title="VIRT :  virtual memory usage 虚拟内存"></a>VIRT :  virtual memory usage 虚拟内存</h3>
      <p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等</p>
<p>注意：假如进程申请100m的内存，但实际只使用了10m,那么它会申请100m，而不是实际的使用量10m.</p>

        <h3 id="RES-resident-memory-usage-常驻内存（单位kb）"   >
          <a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="heading-link"><i class="fas fa-link"></i></a><a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="headerlink" title="RES  :  resident memory usage 常驻内存（单位kb）"></a>RES  :  resident memory usage 常驻内存（单位kb）</h3>
      <p>1、进程当前使用的内存大小，但不包括swap out</p>
<p>2、包含其他进程的共享</p>
<p>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反</p>
<p>补充说明：<strong>当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT</strong></p>

        <h3 id="SHR-shared-memory-共享内存"   >
          <a href="#SHR-shared-memory-共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#SHR-shared-memory-共享内存" class="headerlink" title="SHR : shared memory 共享内存"></a>SHR : shared memory 共享内存</h3>
      <p>1、除了自身进程的共享内存，也包括其他进行的共享内存</p>
<p>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p>
<p>3、计算某个进程所占物理内存大小公式：RES - SHR</p>
<p>4、swap out后，它将会降下来</p>

        <h3 id="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"   >
          <a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="heading-link"><i class="fas fa-link"></i></a><a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="headerlink" title="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"></a>top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">s ：改变画面更新频率。</span><br><span class="line"></span><br><span class="line">l ：关闭或开启第一行top信息。</span><br><span class="line"></span><br><span class="line">t ：关闭或开启第二行Tasks和第三行Cpus信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">m ：关闭或开启第四行Mem和第五行Swap信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">N ：以PID的大小进行降序排序。</span><br><span class="line"></span><br><span class="line">P：以CPU占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">M：以内存占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">h：显示帮助</span><br><span class="line"></span><br><span class="line">n：设置在进程列表所显示进程的数量</span><br><span class="line"></span><br><span class="line">q：退出top</span><br></pre></td></tr></table></div></figure>




        <h3 id="top命令的使用方法"   >
          <a href="#top命令的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#top命令的使用方法" class="headerlink" title="top命令的使用方法"></a>top命令的使用方法</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">使用格式：top [-] [p] [S] [s] [i] [c]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">p：通过指定监控进程ID来显示某个进程的状态。top -p 进程ID</span><br><span class="line"></span><br><span class="line">S：指定累计模式。</span><br><span class="line"></span><br><span class="line">s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line"></span><br><span class="line">i：使top不显示任何闲置或者僵尸进程。</span><br><span class="line"></span><br><span class="line">c：显示整个命令行而不只是显示命令名称。</span><br></pre></td></tr></table></div></figure>




        <h3 id="Linux查看物理CPU个数、核数、逻辑CPU个数"   >
          <a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><strong>Linux查看物理CPU个数、核数、逻辑CPU个数</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上分配和TLAB</title>
    <url>/2021/06/09/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB/</url>
    <content><![CDATA[
        <h2 id="关于栈上分配和TLAB的理解"   >
          <a href="#关于栈上分配和TLAB的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于栈上分配和TLAB的理解" class="headerlink" title="关于栈上分配和TLAB的理解"></a><strong>关于栈上分配和TLAB的理解</strong></h2>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>在java程序中，new出来的对象时分配在堆空间中的，但是实际的情况是，大部分new出来的对象会进入堆空间中，而并非是全部的对象，其实还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB。</p>

        <h2 id="栈上分配"   >
          <a href="#栈上分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2>
      
        <h4 id="栈上分配是什么？"   >
          <a href="#栈上分配是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配是什么？" class="headerlink" title="栈上分配是什么？"></a>栈上分配是什么？</h4>
      <p>JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上（线程私有，属于栈内存），这样随着方法的调用结束，栈空间的回收就会随着栈上分配的打散后的对象回收掉，不再给GC增加额外的无用负担，从而提升应用程序整体的性能。</p>
<span id="more"></span>


        <h4 id="为什么需要栈上分配？"   >
          <a href="#为什么需要栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要栈上分配？" class="headerlink" title="为什么需要栈上分配？"></a>为什么需要栈上分配？</h4>
      <p>在应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用而开始，方法的调用结束而结束，对于这种对象，就应该考虑将该对象不分配在堆空间中。因为一旦分配在堆空间中，当方法调用结束，没有了引用指向该对象，该对象就需要被GC回收，而如果存在大量的这种情况，对GC来说无疑时一种负担。</p>

        <h4 id="如何开启栈上分配？"   >
          <a href="#如何开启栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启栈上分配？" class="headerlink" title="如何开启栈上分配？"></a>如何开启栈上分配？</h4>
      <p>栈上分配需要的前提：</p>
<p>（1）开启逃逸分析（-XX:+DoEscapeAnalysis）</p>
<p>逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，在Server虚拟机模式下才可以开启（jdk1.6默认开启）</p>
<p>（2）开启标量替换（-XX:+EliminateAllocations）</p>
<p>标量替换的作用是允许将对象根据属性打散后分配在栈上，默认该配置为开启</p>

        <h4 id="如何查看逃逸分析的筛选结果？"   >
          <a href="#如何查看逃逸分析的筛选结果？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何查看逃逸分析的筛选结果？" class="headerlink" title="如何查看逃逸分析的筛选结果？"></a>如何查看逃逸分析的筛选结果？</h4>
      <p>配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果</p>

        <h2 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2>
      
        <h4 id="TLAB是什么？"   >
          <a href="#TLAB是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB是什么？" class="headerlink" title="TLAB是什么？"></a>TLAB是什么？</h4>
      <p>全程叫做：Thread Local Allocation Buffer 即线程本地分配缓存</p>
<p>就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的）。</p>

        <h4 id="为什么需要TLAB？"   >
          <a href="#为什么需要TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要TLAB？" class="headerlink" title="为什么需要TLAB？"></a>为什么需要TLAB？</h4>
      <p>一般来说，对象分配在堆上，而堆是一个全局共享的区域，当多个线程同一时刻操作堆内存分配对象空间时，就需要进行同步，而同步带来的效果就是对象分配效率变差（尽管JVM采用了CAS的形式处理分配失败的情况），但是对于存在竞争激烈的分配场合仍然会导致效率变差。（简而言之：需要TLAB的原因就是提高对象在堆上的分配效率）</p>

        <h4 id="如何开启TLAB？"   >
          <a href="#如何开启TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启TLAB？" class="headerlink" title="如何开启TLAB？"></a>如何开启TLAB？</h4>
      <p>JVM默认开启了TLAB功能，可以使用-XX:+UseTLAB 显示是否开启。</p>

        <h4 id="如何观察TLAB使用情况？"   >
          <a href="#如何观察TLAB使用情况？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何观察TLAB使用情况？" class="headerlink" title="如何观察TLAB使用情况？"></a>如何观察TLAB使用情况？</h4>
      <p>JVM提供了-XX:+PrintTLAB，可以打开跟踪TLAB的使用情况。</p>

        <h4 id="如何调整TLAB默认大小？"   >
          <a href="#如何调整TLAB默认大小？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何调整TLAB默认大小？" class="headerlink" title="如何调整TLAB默认大小？"></a>如何调整TLAB默认大小？</h4>
      <p>-XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小。</p>

        <h2 id="栈上分配和TLAB的对比"   >
          <a href="#栈上分配和TLAB的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配和TLAB的对比" class="headerlink" title="栈上分配和TLAB的对比"></a>栈上分配和TLAB的对比</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">针对点</th>
<th align="center">处于对象分配流程的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈上分配</td>
<td align="center">避免GC无畏负担</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TLAB</td>
<td align="center">加速堆上对象的分配</td>
<td align="center">2</td>
</tr>
</tbody></table></div>

        <h2 id="对象分配流程图"   >
          <a href="#对象分配流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象分配流程图" class="headerlink" title="对象分配流程图"></a>对象分配流程图</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://processon.com/diagraming/609de1d91e08533129c22d0f" >对象分配流程图 - ProcessOn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/mdimages/image-20210514104238560.png" alt="image-20210514104238560"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
