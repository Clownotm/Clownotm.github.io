<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux-Top</title>
    <url>/2021/06/08/Linux-Top/</url>
    <content><![CDATA[<h1 id="Linux命令之Top"><a href="#Linux命令之Top" class="headerlink" title="Linux命令之Top"></a>Linux命令之Top</h1><p><img src="/mdimages/image-20210527113329108.png" alt="image-20210527113329108"></p>
<h3 id="第一行，任务队列信息，同uptime命令的执行结果"><a href="#第一行，任务队列信息，同uptime命令的执行结果" class="headerlink" title="第一行，任务队列信息，同uptime命令的执行结果"></a>第一行，任务队列信息，同uptime命令的执行结果</h3><p>系统时间：11:32:32</p>
<p>运行时间：up 61 days, 23:26</p>
<p>当前登录用户：1 user</p>
<p>负载均衡（uptime）：load average:  1.35, 1.25, 1.29</p>
<p>​                                  average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>（load average数据是每隔5秒检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5，就表明系统在超负荷运转）</p>
<h3 id="第二行，Tasks-任务（进程）"><a href="#第二行，Tasks-任务（进程）" class="headerlink" title="第二行，Tasks - 任务（进程）"></a>第二行，Tasks - 任务（进程）</h3><p>总进程：231total，运行：2 running，休眠：229 sleeping，停止：0 stopped，僵尸进程：0 zombie</p>
<h3 id="第三行，cpu状态信息"><a href="#第三行，cpu状态信息" class="headerlink" title="第三行，cpu状态信息"></a>第三行，cpu状态信息</h3><p>15.2%us【user space】— 用户空间占用CPU的百分比。</p>
<p>4.9%sy 【sysctl】— 内核空间占用CPU的百分比。</p>
<p>0.0%ni  — 改变过优先级的进程占用CPU的百分比。</p>
<p>79.8%id 【idolt】 — 空闲CPU百分比。</p>
<p>0.0%wa 【wait】 — IO等待占用CPU的百分比。</p>
<p>0.0%hi 【Hardware IRQ】— 硬中断占用CPU的百分比。</p>
<p>0.2%si 【Software Interrupts】— 软中断占用CPU的百分比。</p>
<p>0.0%st 【】</p>
<h3 id="第四行，内存状态-Mem"><a href="#第四行，内存状态-Mem" class="headerlink" title="第四行，内存状态 Mem"></a>第四行，内存状态 Mem</h3><p>8060540k total  总内存大小, 6989544k used 已使用内存大小, 1070996k free 空闲内存大小, 1143720k buffers 【缓存的内存量】</p>
<h3 id="第五行，swap交换分区信息"><a href="#第五行，swap交换分区信息" class="headerlink" title="第五行，swap交换分区信息"></a>第五行，swap交换分区信息</h3><p>8208380k total 总内存大小, 942352k used 已使用内存大小,  7266028k free 空闲内存大小, 3101300k cached 【缓冲的交换区总量】</p>
<p>补充说明：可用内存 =  free + buffer + cached</p>
<p>在对内存监控中，时刻注意swap 交换区的 used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，表明真正的内存不够用了。</p>
<h3 id="第六行，空行"><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h3><h3 id="第七行以下：各进程（任务）的状态监控"><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h3><p>PID —- 进程id</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值，负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p>S — 进程状态。D代表不可中断的睡眠状态；R代表运行；S代表睡眠；T代表跟踪/停止；Z代表僵尸进程。</p>
<p>%CPU — 上次更新到现在CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100 秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<p>以下信息默认没展示:</p>
<p>DATA  —  可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位kb。【简单理解，数据占用的内存，真正的该程序要求的数据空间，是真正在运行中要使用的】。</p>
<p>CODE — 可执行代码占用的物理内存大小，单位kb。</p>
<p>可以通过指令f进入 编排基本视图，这里列出了所有可在top基本视图中显示的进程字段，有带 “ * “ 的并且标注为大写字母的字段是可显示的，没有带 “ * “ 并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以移动上下键到这两个字段，然后按d键选择这两个字段，然后按q退出就可以。【提示：按f进入编排基本视图后，如果想进行进程字段显示顺序做修改，使用上下键移动到该字段，然后按右键（即选中该字段），然后上下键移动到需要的位置即可】</p>
<p><img src="/mdimages/image-20210527204228170.png" alt="image-20210527204228170"></p>
<hr>
<h3 id="VIRT-virtual-memory-usage-虚拟内存"><a href="#VIRT-virtual-memory-usage-虚拟内存" class="headerlink" title="VIRT :  virtual memory usage 虚拟内存"></a>VIRT :  virtual memory usage 虚拟内存</h3><p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等</p>
<p>注意：假如进程申请100m的内存，但实际只使用了10m,那么它会申请100m，而不是实际的使用量10m.</p>
<h3 id="RES-resident-memory-usage-常驻内存（单位kb）"><a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="headerlink" title="RES  :  resident memory usage 常驻内存（单位kb）"></a>RES  :  resident memory usage 常驻内存（单位kb）</h3><p>1、进程当前使用的内存大小，但不包括swap out</p>
<p>2、包含其他进程的共享</p>
<p>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反</p>
<p>补充说明：<strong>当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT</strong></p>
<h3 id="SHR-shared-memory-共享内存"><a href="#SHR-shared-memory-共享内存" class="headerlink" title="SHR : shared memory 共享内存"></a>SHR : shared memory 共享内存</h3><p>1、除了自身进程的共享内存，也包括其他进行的共享内存</p>
<p>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p>
<p>3、计算某个进程所占物理内存大小公式：RES - SHR</p>
<p>4、swap out后，它将会降下来</p>
<h3 id="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"><a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="headerlink" title="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"></a>top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s ：改变画面更新频率。</span><br><span class="line"></span><br><span class="line">l ：关闭或开启第一行top信息。</span><br><span class="line"></span><br><span class="line">t ：关闭或开启第二行Tasks和第三行Cpus信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">m ：关闭或开启第四行Mem和第五行Swap信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">N ：以PID的大小进行降序排序。</span><br><span class="line"></span><br><span class="line">P：以CPU占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">M：以内存占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">h：显示帮助</span><br><span class="line"></span><br><span class="line">n：设置在进程列表所显示进程的数量</span><br><span class="line"></span><br><span class="line">q：退出top</span><br></pre></td></tr></table></figure>



<h3 id="top命令的使用方法"><a href="#top命令的使用方法" class="headerlink" title="top命令的使用方法"></a>top命令的使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用格式：top [-] [p] [S] [s] [i] [c]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">p：通过指定监控进程ID来显示某个进程的状态。top -p 进程ID</span><br><span class="line"></span><br><span class="line">S：指定累计模式。</span><br><span class="line"></span><br><span class="line">s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line"></span><br><span class="line">i：使top不显示任何闲置或者僵尸进程。</span><br><span class="line"></span><br><span class="line">c：显示整个命令行而不只是显示命令名称。</span><br></pre></td></tr></table></figure>



<h3 id="Linux查看物理CPU个数、核数、逻辑CPU个数"><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><strong>Linux查看物理CPU个数、核数、逻辑CPU个数</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
  </entry>
</search>
