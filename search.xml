<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello-World</title>
    <url>/2021/06/08/Hello-World/</url>
    <content><![CDATA[
        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
      
        <h3 id="创建一个文档"   >
          <a href="#创建一个文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个文档" class="headerlink" title="创建一个文档"></a>创建一个文档</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="创建一个页面"   >
          <a href="#创建一个页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;new my pageName&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="生成静态页面至public目录"   >
          <a href="#生成静态页面至public目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>


        <h3 id="部署到GitHub"   >
          <a href="#部署到GitHub" class="heading-link"><i class="fas fa-link"></i></a><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<span id="more"></span>


        <h3 id="清理public目录的内容"   >
          <a href="#清理public目录的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理public目录的内容" class="headerlink" title="清理public目录的内容"></a>清理public目录的内容</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></div></figure>


        <h3 id="指令缩写"   >
          <a href="#指令缩写" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo n    （hexo new）</span><br><span class="line">$ hexo g    （hexo generate）</span><br><span class="line">$ hexo d    （hexo deploy）</span><br></pre></td></tr></table></div></figure>


        <h3 id="组合指令"   >
          <a href="#组合指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合指令" class="headerlink" title="组合指令"></a>组合指令</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">$ hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Hexo常用指令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Top</title>
    <url>/2021/06/08/Linux-Top/</url>
    <content><![CDATA[
        <h1 id="Linux命令之Top"   >
          <a href="#Linux命令之Top" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux命令之Top" class="headerlink" title="Linux命令之Top"></a>Linux命令之Top</h1>
      <p><img src="/mdimages/image-20210527113329108.png" alt="image-20210527113329108"></p>

        <h3 id="第一行，任务队列信息，同uptime命令的执行结果"   >
          <a href="#第一行，任务队列信息，同uptime命令的执行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一行，任务队列信息，同uptime命令的执行结果" class="headerlink" title="第一行，任务队列信息，同uptime命令的执行结果"></a>第一行，任务队列信息，同uptime命令的执行结果</h3>
      <p>系统时间：11:32:32</p>
<p>运行时间：up 61 days, 23:26</p>
<p>当前登录用户：1 user</p>
<p>负载均衡（uptime）：load average:  1.35, 1.25, 1.29</p>
<p>​                                  average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>（load average数据是每隔5秒检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5，就表明系统在超负荷运转）</p>
<span id="more"></span>


        <h3 id="第二行，Tasks-任务（进程）"   >
          <a href="#第二行，Tasks-任务（进程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二行，Tasks-任务（进程）" class="headerlink" title="第二行，Tasks - 任务（进程）"></a>第二行，Tasks - 任务（进程）</h3>
      <p>总进程：231total，运行：2 running，休眠：229 sleeping，停止：0 stopped，僵尸进程：0 zombie</p>

        <h3 id="第三行，cpu状态信息"   >
          <a href="#第三行，cpu状态信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三行，cpu状态信息" class="headerlink" title="第三行，cpu状态信息"></a>第三行，cpu状态信息</h3>
      <p>15.2%us【user space】— 用户空间占用CPU的百分比。</p>
<p>4.9%sy 【sysctl】— 内核空间占用CPU的百分比。</p>
<p>0.0%ni  — 改变过优先级的进程占用CPU的百分比。</p>
<p>79.8%id 【idolt】 — 空闲CPU百分比。</p>
<p>0.0%wa 【wait】 — IO等待占用CPU的百分比。</p>
<p>0.0%hi 【Hardware IRQ】— 硬中断占用CPU的百分比。</p>
<p>0.2%si 【Software Interrupts】— 软中断占用CPU的百分比。</p>
<p>0.0%st 【】</p>

        <h3 id="第四行，内存状态-Mem"   >
          <a href="#第四行，内存状态-Mem" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四行，内存状态-Mem" class="headerlink" title="第四行，内存状态 Mem"></a>第四行，内存状态 Mem</h3>
      <p>8060540k total  总内存大小, 6989544k used 已使用内存大小, 1070996k free 空闲内存大小, 1143720k buffers 【缓存的内存量】</p>

        <h3 id="第五行，swap交换分区信息"   >
          <a href="#第五行，swap交换分区信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五行，swap交换分区信息" class="headerlink" title="第五行，swap交换分区信息"></a>第五行，swap交换分区信息</h3>
      <p>8208380k total 总内存大小, 942352k used 已使用内存大小,  7266028k free 空闲内存大小, 3101300k cached 【缓冲的交换区总量】</p>
<p>补充说明：可用内存 =  free + buffer + cached</p>
<p>在对内存监控中，时刻注意swap 交换区的 used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，表明真正的内存不够用了。</p>

        <h3 id="第六行，空行"   >
          <a href="#第六行，空行" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h3>
      
        <h3 id="第七行以下：各进程（任务）的状态监控"   >
          <a href="#第七行以下：各进程（任务）的状态监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h3>
      <p>PID —- 进程id</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值，负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p>S — 进程状态。D代表不可中断的睡眠状态；R代表运行；S代表睡眠；T代表跟踪/停止；Z代表僵尸进程。</p>
<p>%CPU — 上次更新到现在CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100 秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<p>以下信息默认没展示:</p>
<p>DATA  —  可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位kb。【简单理解，数据占用的内存，真正的该程序要求的数据空间，是真正在运行中要使用的】。</p>
<p>CODE — 可执行代码占用的物理内存大小，单位kb。</p>
<p>可以通过指令f进入 编排基本视图，这里列出了所有可在top基本视图中显示的进程字段，有带 “ * “ 的并且标注为大写字母的字段是可显示的，没有带 “ * “ 并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以移动上下键到这两个字段，然后按d键选择这两个字段，然后按q退出就可以。【提示：按f进入编排基本视图后，如果想进行进程字段显示顺序做修改，使用上下键移动到该字段，然后按右键（即选中该字段），然后上下键移动到需要的位置即可】</p>
<p><img src="/mdimages/image-20210527204228170.png" alt="image-20210527204228170"></p>
<hr>

        <h3 id="VIRT-virtual-memory-usage-虚拟内存"   >
          <a href="#VIRT-virtual-memory-usage-虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#VIRT-virtual-memory-usage-虚拟内存" class="headerlink" title="VIRT :  virtual memory usage 虚拟内存"></a>VIRT :  virtual memory usage 虚拟内存</h3>
      <p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等</p>
<p>注意：假如进程申请100m的内存，但实际只使用了10m,那么它会申请100m，而不是实际的使用量10m.</p>

        <h3 id="RES-resident-memory-usage-常驻内存（单位kb）"   >
          <a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="heading-link"><i class="fas fa-link"></i></a><a href="#RES-resident-memory-usage-常驻内存（单位kb）" class="headerlink" title="RES  :  resident memory usage 常驻内存（单位kb）"></a>RES  :  resident memory usage 常驻内存（单位kb）</h3>
      <p>1、进程当前使用的内存大小，但不包括swap out</p>
<p>2、包含其他进程的共享</p>
<p>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反</p>
<p>补充说明：<strong>当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT</strong></p>

        <h3 id="SHR-shared-memory-共享内存"   >
          <a href="#SHR-shared-memory-共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#SHR-shared-memory-共享内存" class="headerlink" title="SHR : shared memory 共享内存"></a>SHR : shared memory 共享内存</h3>
      <p>1、除了自身进程的共享内存，也包括其他进行的共享内存</p>
<p>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p>
<p>3、计算某个进程所占物理内存大小公式：RES - SHR</p>
<p>4、swap out后，它将会降下来</p>

        <h3 id="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"   >
          <a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="heading-link"><i class="fas fa-link"></i></a><a href="#top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下" class="headerlink" title="top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下"></a>top运行中可以通过内部命令对进程的显示方式进行控制：内部命令如下</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">s ：改变画面更新频率。</span><br><span class="line"></span><br><span class="line">l ：关闭或开启第一行top信息。</span><br><span class="line"></span><br><span class="line">t ：关闭或开启第二行Tasks和第三行Cpus信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">m ：关闭或开启第四行Mem和第五行Swap信息（需要连按3次才可以关闭）。</span><br><span class="line"></span><br><span class="line">N ：以PID的大小进行降序排序。</span><br><span class="line"></span><br><span class="line">P：以CPU占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">M：以内存占用率大小进行降序排序。</span><br><span class="line"></span><br><span class="line">h：显示帮助</span><br><span class="line"></span><br><span class="line">n：设置在进程列表所显示进程的数量</span><br><span class="line"></span><br><span class="line">q：退出top</span><br></pre></td></tr></table></div></figure>




        <h3 id="top命令的使用方法"   >
          <a href="#top命令的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#top命令的使用方法" class="headerlink" title="top命令的使用方法"></a>top命令的使用方法</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">使用格式：top [-] [p] [S] [s] [i] [c]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">p：通过指定监控进程ID来显示某个进程的状态。top -p 进程ID</span><br><span class="line"></span><br><span class="line">S：指定累计模式。</span><br><span class="line"></span><br><span class="line">s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line"></span><br><span class="line">i：使top不显示任何闲置或者僵尸进程。</span><br><span class="line"></span><br><span class="line">c：显示整个命令行而不只是显示命令名称。</span><br></pre></td></tr></table></div></figure>




        <h3 id="Linux查看物理CPU个数、核数、逻辑CPU个数"   >
          <a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><strong>Linux查看物理CPU个数、核数、逻辑CPU个数</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上分配和TLAB</title>
    <url>/2021/06/09/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB/</url>
    <content><![CDATA[
        <h2 id="关于栈上分配和TLAB的理解"   >
          <a href="#关于栈上分配和TLAB的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于栈上分配和TLAB的理解" class="headerlink" title="关于栈上分配和TLAB的理解"></a><strong>关于栈上分配和TLAB的理解</strong></h2>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>在java程序中，new出来的对象时分配在堆空间中的，但是实际的情况是，大部分new出来的对象会进入堆空间中，而并非是全部的对象，其实还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB。</p>

        <h2 id="栈上分配"   >
          <a href="#栈上分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2>
      
        <h4 id="栈上分配是什么？"   >
          <a href="#栈上分配是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配是什么？" class="headerlink" title="栈上分配是什么？"></a>栈上分配是什么？</h4>
      <p>JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上（线程私有，属于栈内存），这样随着方法的调用结束，栈空间的回收就会随着栈上分配的打散后的对象回收掉，不再给GC增加额外的无用负担，从而提升应用程序整体的性能。</p>
<span id="more"></span>


        <h4 id="为什么需要栈上分配？"   >
          <a href="#为什么需要栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要栈上分配？" class="headerlink" title="为什么需要栈上分配？"></a>为什么需要栈上分配？</h4>
      <p>在应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用而开始，方法的调用结束而结束，对于这种对象，就应该考虑将该对象不分配在堆空间中。因为一旦分配在堆空间中，当方法调用结束，没有了引用指向该对象，该对象就需要被GC回收，而如果存在大量的这种情况，对GC来说无疑时一种负担。</p>

        <h4 id="如何开启栈上分配？"   >
          <a href="#如何开启栈上分配？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启栈上分配？" class="headerlink" title="如何开启栈上分配？"></a>如何开启栈上分配？</h4>
      <p>栈上分配需要的前提：</p>
<p>（1）开启逃逸分析（-XX:+DoEscapeAnalysis）</p>
<p>逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，在Server虚拟机模式下才可以开启（jdk1.6默认开启）</p>
<p>（2）开启标量替换（-XX:+EliminateAllocations）</p>
<p>标量替换的作用是允许将对象根据属性打散后分配在栈上，默认该配置为开启</p>

        <h4 id="如何查看逃逸分析的筛选结果？"   >
          <a href="#如何查看逃逸分析的筛选结果？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何查看逃逸分析的筛选结果？" class="headerlink" title="如何查看逃逸分析的筛选结果？"></a>如何查看逃逸分析的筛选结果？</h4>
      <p>配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果</p>

        <h2 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2>
      
        <h4 id="TLAB是什么？"   >
          <a href="#TLAB是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB是什么？" class="headerlink" title="TLAB是什么？"></a>TLAB是什么？</h4>
      <p>全程叫做：Thread Local Allocation Buffer 即线程本地分配缓存</p>
<p>就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的）。</p>

        <h4 id="为什么需要TLAB？"   >
          <a href="#为什么需要TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要TLAB？" class="headerlink" title="为什么需要TLAB？"></a>为什么需要TLAB？</h4>
      <p>一般来说，对象分配在堆上，而堆是一个全局共享的区域，当多个线程同一时刻操作堆内存分配对象空间时，就需要进行同步，而同步带来的效果就是对象分配效率变差（尽管JVM采用了CAS的形式处理分配失败的情况），但是对于存在竞争激烈的分配场合仍然会导致效率变差。（简而言之：需要TLAB的原因就是提高对象在堆上的分配效率）</p>

        <h4 id="如何开启TLAB？"   >
          <a href="#如何开启TLAB？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何开启TLAB？" class="headerlink" title="如何开启TLAB？"></a>如何开启TLAB？</h4>
      <p>JVM默认开启了TLAB功能，可以使用-XX:+UseTLAB 显示是否开启。</p>

        <h4 id="如何观察TLAB使用情况？"   >
          <a href="#如何观察TLAB使用情况？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何观察TLAB使用情况？" class="headerlink" title="如何观察TLAB使用情况？"></a>如何观察TLAB使用情况？</h4>
      <p>JVM提供了-XX:+PrintTLAB，可以打开跟踪TLAB的使用情况。</p>

        <h4 id="如何调整TLAB默认大小？"   >
          <a href="#如何调整TLAB默认大小？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何调整TLAB默认大小？" class="headerlink" title="如何调整TLAB默认大小？"></a>如何调整TLAB默认大小？</h4>
      <p>-XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小。</p>

        <h2 id="栈上分配和TLAB的对比"   >
          <a href="#栈上分配和TLAB的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈上分配和TLAB的对比" class="headerlink" title="栈上分配和TLAB的对比"></a>栈上分配和TLAB的对比</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">针对点</th>
<th align="center">处于对象分配流程的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈上分配</td>
<td align="center">避免GC无畏负担</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TLAB</td>
<td align="center">加速堆上对象的分配</td>
<td align="center">2</td>
</tr>
</tbody></table></div>

        <h2 id="对象分配流程图"   >
          <a href="#对象分配流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象分配流程图" class="headerlink" title="对象分配流程图"></a>对象分配流程图</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://processon.com/diagraming/609de1d91e08533129c22d0f" >对象分配流程图 - ProcessOn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/mdimages/image-20210514104238560.png" alt="image-20210514104238560"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的强、软、弱、虚引用</title>
    <url>/2021/06/09/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[
        <h1 id="Java对象的强引用、软引用、弱引用、虚引用"   >
          <a href="#Java对象的强引用、软引用、弱引用、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对象的强引用、软引用、弱引用、虚引用" class="headerlink" title="Java对象的强引用、软引用、弱引用、虚引用"></a>Java对象的强引用、软引用、弱引用、虚引用</h1>
      
        <h3 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>
      <p>在Java中，除了基本数据类型外，还有引用数据类型；Java根据其生命周期的长短，将引用分为以下4类：强引用、软引用、弱引用和虚引用。</p>

        <h3 id="基本数据类型"   >
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3>
      <ul>
<li>整数类型(byte、short、int、long)</li>
<li>浮点类型(float、double)</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>

        <h3 id="引用数据类型"   >
          <a href="#引用数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3>
      <ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
<span id="more"></span>


        <h3 id="基本数据类型图"   >
          <a href="#基本数据类型图" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型图" class="headerlink" title="基本数据类型图"></a>基本数据类型图</h3>
      <p><img src="/mdimages/image-20210609235746769.png" alt="image-20210609235746769"></p>

        <h3 id="引用类图"   >
          <a href="#引用类图" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类图" class="headerlink" title="引用类图"></a>引用类图</h3>
      <p><img src="/mdimages/image-20210610000110261.png" alt="image-20210610000110261"></p>

        <h3 id="一、强引用（默认支持模式）"   >
          <a href="#一、强引用（默认支持模式）" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、强引用（默认支持模式）" class="headerlink" title="一、强引用（默认支持模式）"></a>一、强引用（默认支持模式）</h3>
      <p>把一个对象赋给一个引用变量，这个引用变量就是一个强引用。(如：Object obj = new Object()中的obj就是强引用)。</p>
<p>即通过关键字new创建的对象所关联的引用就是强引用，此时它处于可达状态（如果不懂可达状态的概念，可参阅GCRoots相关知识），当JVM内存空间不足时，JVM宁愿抛出OOM运行时错误使程序终止，也不会回收“存活”对象来解决内存不足的问题。因此强引用是造成java内存泄漏的主要原因之一。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为Null，一般认为就是可以被垃圾收集的了（具体回收时机要看垃圾收集策略）。</p>
<p>知识补充：当一个对象处于可达状态时，jvm会对其标记为存活对象。</p>

        <h3 id="二、软引用"   >
          <a href="#二、软引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h3>
      <p>软引用是一种相对于强引用弱化一些的引用，需要用java.lang.ref.SoftReference类来实现。</p>
<p>对于只要软引用的对象来说，当系统内存充足时，它不会被回收，当系统内存不足时，它会被回收。</p>
<p>软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中，后续可以调用ReferenceQueue的poll()方法来检查是否有它所关联的对象被回收。如果队列为空，将返回一个null，否则返回队列中前面的一个Reference对象。</p>

        <h4 id="应用场景："   >
          <a href="#应用场景：" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>  软引用通常用在对内存敏感的程序中，比如高速缓存就使用了软引用，内存足够时就保留，不足够时就回收。如MyBatis中就用到。</p>

        <h4 id="代码演示："   >
          <a href="#代码演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">        <span class="comment">//这里将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建大对象数组30M</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;软引用==&gt;&quot;</span>+reference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<p><img src="/mdimages/image-20210611004111118.png" alt="image-20210611004111118"></p>
<p>设置JVM参数：-Xms10m -Xmx10m -XX:+PrintGCDetails（初始化堆内存大小，堆内存最大大小，开启GC回收日志）</p>
<p><img src="/mdimages/image-20210611004543872.png" alt="image-20210611004543872"></p>
<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;956K(9728K), <span class="number">0.0008888</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1372K-&gt;504K(2560K)] 1825K-&gt;1044K(9728K), <span class="number">0.0010868</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 504K-&gt;488K(2560K)] 1044K-&gt;1068K(9728K), <span class="number">0.0009916</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 488K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 580K-&gt;976<span class="title">K</span><span class="params">(7168K)</span>] 1068K-&gt;976<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0093101 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 976K-&gt;976K(9728K), <span class="number">0.0004390</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 976K-&gt;958<span class="title">K</span><span class="params">(7168K)</span>] 976K-&gt;958<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3520K-&gt;3520<span class="title">K</span><span class="params">(1056768K)</span>], 0.0095406 secs] [Times: user</span>=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">软引用==&gt;<span class="keyword">null</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 61K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">3</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f700</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 958K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">13</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff6efa08</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3554K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 391<span class="title">K</span>, <span class="title">capacity</span> 394<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Exception</span> <span class="title">in</span> <span class="title">thread</span> &quot;<span class="title">main</span>&quot; <span class="title">java</span>.<span class="title">lang</span>.<span class="title">OutOfMemoryError</span>: <span class="title">Java</span> <span class="title">heap</span> <span class="title">space</span></span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">mybatis</span>.<span class="title">Main</span>.<span class="title">main</span>(<span class="title">Main</span>.<span class="title">java</span>:12)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 1</span></span><br></pre></td></tr></table></div></figure>

<p>发现当内存不够的时候软引用对象就会被回收。</p>

        <h3 id="三、弱引用"   >
          <a href="#三、弱引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h3>
      <p>弱引用需要通过java.lang.ref.WeakReference类实现。生命周期比软引用更短。</p>
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都将回收该对象占用的内存。</p>
<p>弱引用还可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，JVM就会把这个弱引用加入与之关联的引用队列中。</p>

        <h4 id="应用场景：-1"   >
          <a href="#应用场景：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>弱引用同样可用于内存敏感的缓存。</p>
<p>弱引用适合解决某些地方的内存泄露问题，比如ThreadLocal，ThreadLocal静态内部类ThreadLocalMap中的Entiry中的key就是一个虚引用。</p>

        <h4 id="代码演示：-1"   >
          <a href="#代码演示：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;强引用对象====&gt;&quot;</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象====&gt;&quot;</span>+weakReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将obj赋值为null，让其不存在强引用</span></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//手动触发垃圾回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========GC回收后的结果==========&quot;</span>);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">强引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">弱引用对象====&gt;java.lang.Object@3b07d329</span><br><span class="line">==========GC回收后的结果==========</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="补充WeakHashMap"   >
          <a href="#补充WeakHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充WeakHashMap" class="headerlink" title="补充WeakHashMap"></a>补充WeakHashMap</h4>
      <p>WeakHashMap的键是”弱键”，也就是键的引用是一个弱引用。</p>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">7</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;<span class="comment">//这里将key置为null，让其不存在强引用</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map+<span class="string">&quot;===&gt;&quot;</span>+map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;<span class="number">7</span>=WeakHashMap&#125;</span><br><span class="line">&#123;&#125;===&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="四、虚引用"   >
          <a href="#四、虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h3>
      <p>虚引用需要java.lang.ref.PhantomReference类实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用，也不能通过它访问对象，必须和引用队列(ReferenceQueue)联合使用。</p>
<p>主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。PhantomReference的get方法总是返回null,无论在GC前还是GC后，PhantomReference在GC前poll方法是null，GC后poll方法是获取被回收的对象，设置虚引用关联的唯一目的就是在这个对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步的处理（类似SpringAop的后置通知）。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>Java允许使用finalize()方法在垃圾回收器将对象从内存中清除出去之前做必要的清理工作。</p>

        <h4 id="应用场景：-2"   >
          <a href="#应用场景：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4>
      <p>可用来跟踪对象被垃圾回收器回收的时候添加一些处理。</p>

        <h4 id="代码演示：-2"   >
          <a href="#代码演示：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h4>
      <p>对象无重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//这里睡0.1秒确保GC线程执行完再打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;在打印看看&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">第一次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line">在打印看看<span class="keyword">null</span></span><br></pre></td></tr></table></div></figure>

<p>注意：</p>
<p>ReferenceQueue.poll()方法调用拿到对象后，再调用就无该对象了。</p>
<p>代码演示：</p>
<p>对象重写finalize()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        ReferenceQueue&lt;User&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;User&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(user, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将强引用去掉</span></span><br><span class="line">        user = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;GC回收前&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC之后&quot;</span>+queue.poll());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);<span class="comment">//等待GC线程执行完毕再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC之后&quot;</span>+queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC要把我清除了/(ㄒoㄒ)/~~......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">GC回收前<span class="keyword">null</span></span><br><span class="line">GC要把我清除了/(ㄒoㄒ)/~~......</span><br><span class="line">第一次GC之后<span class="keyword">null</span></span><br><span class="line">第二次GC之后java.lang.ref.PhantomReference@3b07d329</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="结论"   >
          <a href="#结论" class="heading-link"><i class="fas fa-link"></i></a><a href="#结论" class="headerlink" title="结论"></a>结论</h4>
      <p>对于虚引用，如果被引用的对象没有重写finalize方法，那么在第一次垃圾回收将该对象销毁之后，就会将虚引用对象添加到引用队列中。如果被引用的对象重写了finalize方法，那么则是在执行完第二次垃圾回收后，才将虚引用对象添加到其关联的引用队列中。</p>

        <h4 id="ReferenceQueue引用队列"   >
          <a href="#ReferenceQueue引用队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReferenceQueue引用队列" class="headerlink" title="ReferenceQueue引用队列"></a>ReferenceQueue引用队列</h4>
      <p>对象在被回收之前要被引用队列保存一下。GC之前对象不放在队列中，GC之后对象才放入队列中。</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <ul>
<li>强引用是不会被垃圾回收器随意回收的，也是造成java内存溢出的主要原因之一。</li>
<li>软引用是通过java.lang.ref.SoftReference类来实现，当JVM内存不足时，便会回收软引用所引用的对象。</li>
<li>弱引用是通过java.lang.ref.WeakReference类来实现，只要垃圾回收器回收垃圾时，无论内存足不足够都会把弱引用回收掉。</li>
<li>虚引用是通过java.lang.ref.PhantomReference类来实现，若一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPool线程池</title>
    <url>/2021/06/11/ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[
        <h1 id="ThreadPool线程池"   >
          <a href="#ThreadPool线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1>
      
        <h3 id="线程池是什么"   >
          <a href="#线程池是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3>
      <p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后再创建线程后自动启动这些任务。</p>

        <h3 id="为什么用线程池"   >
          <a href="#为什么用线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3>
      <p>线程池的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务执行。</p>
<p>主要的特点是：线程复用；控制最大并发数；管理线程。</p>
<p>好处：</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<span id="more"></span></li>
</ol>

        <h3 id="线程池如何使用"   >
          <a href="#线程池如何使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h3>
      <p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类。</p>
<p>类图：</p>
<p><img src="/mdimages/image-20210611153209223.png" alt="image-20210611153209223"></p>
<p>Java通过Executors提供了以下几种线程池：</p>
<ul>
<li><p>Executors.newScheduledThreadPool(int corePoolSize);创建一个支持定时以及周期性执行任务的线程池。</p>
</li>
<li><p>Executors.newWorkStealingPool(int);JDK8新增，使用目前机器上可用的处理器作为它的并行级别。</p>
</li>
<li><p>Executors.newFixedThreadPool(int);创建一个定长的线程池，可控制线程最大并发数，超过的线程会在队列中等待。</p>
</li>
<li><p>Executors.newSingleThreadExecutor();创建只有一个线程的线程池，保证所有任务按照FIFO执行；</p>
</li>
<li><p>Executors.newCachedThreadPool();创建一个可缓存线程池；</p>
<p>以上线程池除了newWorkStealingPool底层是使用ForkJoinPool创建外，其它线程池都是使用ThreadPoolExecutor创建的。</p>
</li>
</ul>

        <h4 id="重点介绍："   >
          <a href="#重点介绍：" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点介绍：" class="headerlink" title="重点介绍："></a>重点介绍：</h4>
      <ol>
<li><p>newFixedThreadPool(int)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;====&gt;&quot;</span>+finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>====&gt;<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>====&gt;<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>====&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为线程池大小为<span class="number">3</span>，每个任务输出finalI后sleep2秒，可以看到每两秒打印<span class="number">3</span>个数字，并且每两秒始终打印的都是三个线程轮流工作。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newSingleThreadExecutor()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO【先进先出】,LIFO【后进先出】,优先级)执行。</li>
<li>newSingleThreadExecutor创建的线程池corePoolSize和maximimPoolSize都设置为1,它使用的阻塞队列是LinkedBlockingQueue。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">因为newSingleThreadExecutor线程池中始终只有一个工作线程工作，所以可以看到工作的线程始终是同一个。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newCachedThreadPool()</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<ul>
<li>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newCachedThreadPool将corePooleSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用的阻塞队列是SynchronousQueue，也即是任务来了就创建线程运行，当线程空闲超过60秒就销毁线程。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//始终保持执行第二个任务的时候第一个任务已经完成</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>* finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cachedThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">从底层可以看出newCachedThreadPool创建的线程池为无线大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</span><br></pre></td></tr></table></div></figure></li>
<li><p>newScheduledThreadPool(int corePoolSize)</p>
<p>底层代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>特点：</p>
<p>创建一个周期线程池，支持定时及周期性任务执行。</p>
<p>代码演示1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;delay.....延迟3秒&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//等待任务执行完再关闭</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        <span class="comment">//无论任务是否执行完都立马关闭</span></span><br><span class="line">        <span class="comment">//scheduledThreadPool.shutdownNow();</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程执行..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果1：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">main线程执行..........</span><br><span class="line">delay.....延迟<span class="number">3</span>秒</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<p>代码演示2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果2：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">04</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">07</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">10</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">13</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">16</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Fri Jun <span class="number">11</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">19</span> CST <span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br><span class="line">表示延迟<span class="number">3</span>秒后每<span class="number">3</span>秒执行一次任务。</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h3 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3>
      
        <h4 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="七大参数说明"   >
          <a href="#七大参数说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#七大参数说明" class="headerlink" title="七大参数说明"></a>七大参数说明</h4>
      <ol>
<li>corePoolSize：线程池中的常驻核心线程数。</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数量，此值必须大于1。</li>
<li>keepAliveTime：多余的空闲线程的存活时间。当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。</li>
<li>unit：keepAliveTime的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。</li>
<li>handler：拒接策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时如何来拒接。</li>
</ol>

        <h4 id="线程池的工作原理"   >
          <a href="#线程池的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h4>
      <ol>
<li>在创建了线程池后，等待提交过来的任务请求。</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做如下判断：</li>
</ol>
<p>​      2.1.如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p>
<p>​      2.2.如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p>
<p>​      2.3.如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p>​      2.4.如果队列满了且正在运行的线程数大于或等于mamimumPoolSize，那么线程池会启动饱和拒接策略来执行；</p>
<p>  3.当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
<p>  4.当一个线程无事可做超过一定时间(keepAliveTime)时，线程池会判断：</p>
<p>​     如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。最后线程池的所有任务完成后它最终会收缩到corePoolSize的大小。</p>

        <h4 id="线程池的拒接策略"   >
          <a href="#线程池的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略" class="headerlink" title="线程池的拒接策略"></a>线程池的拒接策略</h4>
      
        <h5 id="线程池的拒接策略是什么"   >
          <a href="#线程池的拒接策略是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的拒接策略是什么" class="headerlink" title="线程池的拒接策略是什么"></a>线程池的拒接策略是什么</h5>
      <p>等待队列已经排满了，再也塞不进新任务，同时线程池中的maximumPoolSize也达到了，无法进行为新任务服务，这个时候就需要拒接策略机制合理的处理这个问题。</p>

        <h5 id="JDK内置的拒接策略"   >
          <a href="#JDK内置的拒接策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#JDK内置的拒接策略" class="headerlink" title="JDK内置的拒接策略"></a>JDK内置的拒接策略</h5>
      <ul>
<li><p>AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行。</p>
</li>
<li><p>CallerRunsPolicy：”调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p>
</li>
<li><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列尝试再次提交当前任务。</p>
</li>
<li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案。</p>
<p> 以上内置拒接策略均实现了RejectedExecutionHandler接口。</p>
</li>
</ul>
<p><img src="/mdimages/image-20210612141336672.png" alt="image-20210612141336672"></p>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>
      <p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p>
<p>Executors返回的线程池对象的弊端如下：</p>
<ol>
<li><p>newFixedThreadPool和newSingleThreadPool：</p>
<p>允许的请求队列长度为Integer.MAX_VALUE,长度约为21亿左右，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p>newCachedThreadPool和newScheduledThreadPool:</p>
<p>允许的创建最大线程数量为Integer.MAX_VALUE,长度约为21亿左右，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ol>

        <h3 id="自定义线程池核心线程数的考量"   >
          <a href="#自定义线程池核心线程数的考量" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义线程池核心线程数的考量" class="headerlink" title="自定义线程池核心线程数的考量"></a>自定义线程池核心线程数的考量</h3>
      <ul>
<li><p>CPU密集型</p>
<p>任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量。</p>
<p>参考公式：CPU核数+1个线程</p>
</li>
<li><p>IO密集型</p>
<p>任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力，浪费在等待。</p>
<p>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>参考公式：CPU核数/1-阻塞系数      阻塞系数在0.8~0.9之间</p>
<p>比如8核CPU：8/1-0.9=80个线程数</p>
</li>
<li><p>CPU核数计算</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(processors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="知识补充"   >
          <a href="#知识补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2>
      
        <h3 id="阻塞队列"   >
          <a href="#阻塞队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3>
      
        <h4 id="阻塞队列的概念"   >
          <a href="#阻塞队列的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列的概念" class="headerlink" title="阻塞队列的概念"></a>阻塞队列的概念</h4>
      <p>阻塞队列它是一种队列，是一种数据结构，阻塞队列在数据结构中所起的作用如下图所示：</p>
<p><img src="/mdimages/image-20210613135406120.png" alt="image-20210613135406120"></p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li>
<li>当阻塞队列时满时，往队列里添加元素的操作将会被阻塞。</li>
<li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它的线程往空的队列插入新的元素。</li>
<li>视图往已满的阻塞队列中添加元素的线程同样也会被阻塞，直到其它线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来后才继续新增。</li>
</ul>

        <h4 id="使用阻塞队列的好处"   >
          <a href="#使用阻塞队列的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用阻塞队列的好处" class="headerlink" title="使用阻塞队列的好处"></a>使用阻塞队列的好处</h4>
      <p>在多线程环境下，所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤醒。</p>
<p>而使用阻塞队列(BlockingQueue)，不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些操作都交给阻塞队列处理。</p>
<p>在JDK1.5前，在多线程环境下，我们都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，会给我们的程序带来不小的复杂度。</p>

        <h4 id="BlockingQueue的核心方法"   >
          <a href="#BlockingQueue的核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">pull(time,unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">抛出异常</td>
<td align="left">当阻塞队列满时，再往队列里add插入元素会抛出java.lang.IllegalStateException: Queue full；<br />当阻塞队列空时，在往队列里remove移除元素会抛出NoSuchElementException;</td>
</tr>
<tr>
<td align="center">特殊值</td>
<td align="left">插入方法offer(e)，成功返回true，失败返回false；<br />移除方法poll()，成功返回出队列的元素，队列里面没有就返回null;</td>
</tr>
<tr>
<td align="center">一直阻塞</td>
<td align="left">当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或者响应中断退出；<br />当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用；</td>
</tr>
<tr>
<td align="center">超时退出</td>
<td align="left">当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出；<br />当阻塞队列空时，队列会阻塞消费者线程一定时间，超过限时后消费者线程会退出；</td>
</tr>
</tbody></table></div>
<p><img src="/mdimages/image-20210613144430983.png" alt="image-20210613144430983"></p>
<p>其中SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然.</p>

        <h4 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4>
      <ul>
<li>生产者消费者模式</li>
<li>线程池</li>
<li>消息中间件</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2021/06/14/ThreadLocal/</url>
    <content><![CDATA[
        <h3 id="ThreadLocal"   >
          <a href="#ThreadLocal" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3>
      
        <h4 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h4>
      <p>多线程访问同一个共享变量容易出现并发问题，特别是多个线程需要对一个共享变量进行写入的时候，为了保证线程安全，一般需要在访问共享变量的时候进行适当的同步(加锁)。</p>

        <h4 id="ThreadLocal是什么"   >
          <a href="#ThreadLocal是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4>
      <p>从JDK1.2的版本开始就提供了java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量副本，从而避免了线程安全问题。</p>
<span id="more"></span>


        <h4 id="ThreadLocal代码演示"   >
          <a href="#ThreadLocal代码演示" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal代码演示" class="headerlink" title="ThreadLocal代码演示"></a>ThreadLocal代码演示</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; num = ThreadLocal.withInitial(()-&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num.set(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        resource.setNum();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程：&quot;</span>+resource.getNum());</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程：&quot;</span>+resource.getNum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">A线程：<span class="number">1</span></span><br><span class="line">main线程：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<p>结论</p>
<p>多个线程操作共享变量互不干扰。</p>

        <h4 id="ThreadLocal的数据结构"   >
          <a href="#ThreadLocal的数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a>ThreadLocal的数据结构</h4>
      <p><img src="/mdimages/image-20210614234128613.png" alt="image-20210614234128613"></p>
<p>Thread类中有一个类型为ThreadLocal.ThreadLocalMap的成员变量（实例变量）threadLocals，也就是说每个线程都有一个自己的ThreadLocalMap.</p>
<p>ThreadLocalMap是ThreadLocal类中的一个静态内部类，内部维护着一个Entry[] table，可以简单地认为key是ThreadLocal，value就是set方法放入的值(而实际上key并不是ThreadLocal本身，而是它的一个弱引用)。</p>
<p>每个线程在往ThreadLocal放值的时候，都会往自己的ThreadLocalMap里存放值，读数据的时候也是以ThreadLocal作为key，在ThreadLocalMap里找对应的值，从而实现线程隔离。</p>
<p>ThreadLocalMap有点类似HashMap的结构，只是HashMap是由数组+链表(或红黑树)实现的，而ThreadLocalMap中没有链表结构。</p>

        <h4 id="ThreadLocal-set-方法原理"   >
          <a href="#ThreadLocal-set-方法原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal-set-方法原理" class="headerlink" title="ThreadLocal.set()方法原理"></a>ThreadLocal.set()方法原理</h4>
      <p>源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">      ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//从当前线程中获取ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//如果ThreadLocalMap为null则创建，否则进行ThreadLocalMap的set方法</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重点在ThreadLocalMap的set方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//通过key计算在散列表中的对应位置</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  </span><br><span class="line">     <span class="comment">//遍历当前key值对应的槽中Entry数据为空，则说明散列数组这里没有数据冲突，跳出for循环，直接set数据到对应的槽中</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">       <span class="comment">//进入循环体，说明key值对应的槽中Entry数据不为空</span></span><br><span class="line">         <span class="comment">//如果槽中已存在的Entry的key值即k == key(也即是说是同个ThreadLocal)，那么set操作就是一个替换操作，做替换逻辑，直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//如果槽中已存在的Entry的key值即k == null,说明当前槽位的Entry是过期数据，执行replaceStaleEntry()替换过期数据方法，然后返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//来到这里，说明key值对应的槽中Entry数据为null，那么直接创建一个新的Entry对象指向对应的槽位</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="comment">//执行++size操作，设置ThreadLocalMap的长度</span></span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">//调用cleanSomeSlots做一次启发式清理工作，清理散列数组中Entry的key过期的数据</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         <span class="comment">//如果清理完成，未清理任何数据，且size大于等于阈值（数组长度的2/3，一开始是16*2/3等于10），则进行rehash()操作</span></span><br><span class="line">         <span class="comment">//rehash中会先进行一轮探测式清理，清理过期key，清理完成后如果size &gt;= threshold - threshold / 4,就会执行扩容resize()。</span></span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用expungeStaleEntries做一次探测式清理工作</span></span><br><span class="line">     expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">     <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">         resize();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>总结：ThreadLocal的set方法，重点在ThreadLocalMap的set方法。</p>
<ol>
<li>首先计算当前set进来的threadLocal（key）在散列表中的对应位置，然后判断该槽位的Entry数据是否为空，如果为空说明散列数组没有数据冲突，跳出循环，直接set数据到对应的槽位中；</li>
<li>如果该槽位Entry数据不为空，那么首先判断该槽位的key值和set进来的key值是否相同，如果相同说明是一个替换操作，做替换逻辑然后直接返回；</li>
<li>如果不相同，接下来先判断该槽位的key是否为null，如果等于null，说明该槽位的Entry是过期数据，则执行替换过期数据逻辑，然后返回；</li>
<li>整个循环执行完毕后，继续往下执行说明向后迭代的过程中遇到了Entry为null的情况，那么直接新建一个Entry指向该槽位，然后设置threadLocalMap的长度加1；</li>
<li>然后做一次cleanSomeSlots启发式清理工作，清理散列数组中Entry的key过期的数据；</li>
<li>如果清理工作完成后，未清理到任何数据，且threadLocalMap的长度size超过了阈值(数组长度的2/3)，则进行rehash（）操作；</li>
<li>rehash（）中会先进行一轮探测式清理，清理过期key的数据，清理完成后如果threadLocalMap的长度size &gt;= threshold - threshold / 4(即大于等于3/4*threshold),那么就执行真正的扩容逻辑resize();</li>
</ol>

        <h4 id="ThreadLocal-get-方法原理"   >
          <a href="#ThreadLocal-get-方法原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal-get-方法原理" class="headerlink" title="ThreadLocal.get()方法原理"></a>ThreadLocal.get()方法原理</h4>
      <p>源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">//从当前线程中获取ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据当前ThreadLocal实例查询其对应的Entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果map为null，则执行setInitialValue()方法</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//通过key计算在散列表中的对应位置（即索引）</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="comment">//如果槽位Entry不为null并且该Entry.key和查找的key一致，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="comment">//如果槽位Entry不为null，但该Entry.key和查找的key不一致</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先获取当前槽位的key值；</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//如果当前槽位key值（k） 和 查找的key值一致，则返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">//如果当前的槽位key值（k）为null，则进行一次探测式数据清理</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//如果当前的槽位key值（k）不为null，则获取下一槽位的索引</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                <span class="comment">//根据获取到的下一槽位的索引，查询对应的槽位Entry</span></span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前key对应的槽位Entry为null，那么直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没重写initialValue方法那么直接返回null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>总结：ThreadLocal的get方法，重点在ThreadLocalMap的getEntry方法。</p>
<ol>
<li><p>首先通过查找key值（threadLocal）计算出散列表中的槽位，如果槽位的Entry为null，那么直接返回null；</p>
</li>
<li><p>如果不为null，那么判断该槽位的Entry的key和查找的key是否一致，如果一致则直接返回；</p>
</li>
<li><p>如果该槽位key值为null，那么进行一次探测式数据清理；</p>
</li>
<li><p>如果不为null，则获取下一槽位的Entry继续对比；</p>
</li>
<li><p>直到整个散列表数组对比完都没匹配上，那么同样返回null；</p>
</li>
</ol>

        <h4 id="ThreadLocalMap的Hash算法"   >
          <a href="#ThreadLocalMap的Hash算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap的Hash算法" class="headerlink" title="ThreadLocalMap的Hash算法"></a>ThreadLocalMap的Hash算法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></div></figure>

<p>ThreadLocalMap中的hash算法很简单，最关键的就是threadLocalHashCode 值的计算，ThreadLocal中有一个属性HASH_INCREMENT = 0x61c88647，这个值很特殊，它是斐波那契数也叫黄金分割数。每当创建一个ThreadLocal对象，这个ThreadLocal.nextHashCode这个值就会增长 0x61c88647。</p>

        <h4 id="ThreadLocalMap如何处理Hash冲突"   >
          <a href="#ThreadLocalMap如何处理Hash冲突" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap如何处理Hash冲突" class="headerlink" title="ThreadLocalMap如何处理Hash冲突"></a>ThreadLocalMap如何处理Hash冲突</h4>
      <p>虽然ThreadLocalMap中使用了黄金分割数来作为hash计算因子，大大减少了Hash冲突的概率，但是仍然会存在冲突。当遇到冲突的时候，ThreadLocalMap就会线性向后查找，一直找到Entry为null的槽位才会停止查找，将当前元素放入此槽位中。当在迭代过程中遇到Entry不为null且key值相等的情况，那么直接替换，如果Entry中的key为null，那么就会执行一次探测式清理数据操作。</p>

        <h4 id="ThreadLocalMap过期key的启发式清理和探测式清理"   >
          <a href="#ThreadLocalMap过期key的启发式清理和探测式清理" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap过期key的启发式清理和探测式清理" class="headerlink" title="ThreadLocalMap过期key的启发式清理和探测式清理"></a>ThreadLocalMap过期key的启发式清理和探测式清理</h4>
      <ul>
<li><p>启发式清理，也就是cleanSomeSlots方法，是以当前Entry往后清理，遇到值为null则结束清理，属于线性探测清理。</p>
</li>
<li><p>探测式清理，也就是expungeStaleEntry方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的Entry设置为null，沿途中碰到未过期的数据则将此数据rehash后重新在table数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放在最靠近此位置的Entry=null的桶中，使rehash后Entry数据距离正确的桶的位置更近一些。</p>
</li>
</ul>

        <h4 id="ThreadLocalMap扩容机制"   >
          <a href="#ThreadLocalMap扩容机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h4>
      <p>在ThreadLocalMap的set()方法最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash（）方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></div></figure>

<p>接下来看rehash()的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>rehash方法首先会进行探测式清理工作，从数组table的起始位置往后清理，清理完成之后，table中可能有一些key为null的Entry数据被清理掉，所以此时通过判断 size &gt;= threshold - threshold / 4 也就是 size &gt;= threshold * 3/4 来决定是否扩容。</p>
<p>所以要清楚，执行rehash()的阈值是 sz &gt;= threshold ，执行真正扩容resize()的阈值是 size &gt;= threshold - threshold / 4。</p>
<p>接着看 resize()方法的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Entry[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">     Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">         Entry e = oldTab[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">             <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, newLen);</span><br><span class="line">                 newTab[h] = e;</span><br><span class="line">                 count++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     setThreshold(newLen);</span><br><span class="line">     size = count;</span><br><span class="line">     table = newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>从源码中可以看出，每次扩容后的容量为原来的2倍，扩容后的table的大小为 oldLen * 2，然后遍历老的散列表，重新计算hash位置，然后放到新的table数组中，如果出现hash冲突则往后找最近的entry为null的槽位，遍历完成之后，oldTab中所有的entry数据都已经放入到新的table中了。重新计算table下一次扩容的阈值。</p>

        <h4 id="ThreadLocal的注意事项"   >
          <a href="#ThreadLocal的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal的注意事项" class="headerlink" title="ThreadLocal的注意事项"></a>ThreadLocal的注意事项</h4>
      <ul>
<li><p>读取到脏数据</p>
<p>线程复用会造成脏数据。由于线程池会复用Thread对象，因此Thread类的成员变量threadLocals也会被复用。如果在线程run()方法中不显示调用remove()清理与线程相关的ThreadLocal信息，并且下一个线程不调用set()设置初始值，就可能get()到上个线程设置的值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(finalI == <span class="number">0</span>) &#123;</span><br><span class="line">                    threadLocal.set(finalI);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;     &quot;</span>+threadLocal.get());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>     <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>     <span class="keyword">null</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>内存泄漏</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有持有外部强引用，那么系统发生GC的时候，这个ThreadLocal就会被回收，导致ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，导致value永远存在无法被回收，出现内存泄漏。</p>
<p>其实，ThreadLocalMap的get、set、remove方法在执行的时候都会清除ThreadLocalMap里面所有key为null的value数据，所以每次用完ThreadLocal后，都要及时显式的调用remove方法清理。</p>
</li>
</ul>

        <h4 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4>
      <ol>
<li>为每个线程分配一个JDBC连接Connection，这样就可以保证每个线程都在各自的Connection上进行数据库的操作，不会出现A线程关了B线程正在使用的Connection;</li>
<li>JDK1.7的SimpleDateFormat不是线程安全的，可以用ThreadLocal来解决；当然JDK1.8开始java.time.format.DateTimeFormatter是线程安全的。</li>
<li>应用于变量在线程间隔离但在方法或类间共享的场景。</li>
</ol>

        <h4 id="思考"   >
          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h4>
      <p>ThreadLocal的key是弱引用，那么在ThreadLocal.get()的时候，发生GC之后，key是否是null？</p>
<p>首先我们回忆一下，使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只持有弱引用，那么就会被回收。</p>
<p>这个问题刚开始看，如果没注意，弱引用，而且还发生垃圾回收，那么肯定会觉得key是null，但是题目中说了在ThreadLocal.get()操作，从源码中可以知道ThreadLocal的get方法是一个实例方法，那么ThreadLocal.get()操作，其实还是有强引用存在的，所以key并不会被回收，也就不会为null。如果我们的强引用不存在的话，那么key就会被回收，也就是会出现value没被回收，而key被回收，导致value永远存在，出现内存泄漏。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
